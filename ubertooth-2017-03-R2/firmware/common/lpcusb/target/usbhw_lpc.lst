ARM GAS  /tmp/cc3mLhQ4.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"usbhw_lpc.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.Wait4DevInt,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	Wait4DevInt:
  24              	.LFB0:
  25              		.file 1 "../common/lpcusb/target/usbhw_lpc.c"
   1:../common/lpcusb/target/usbhw_lpc.c **** /*
   2:../common/lpcusb/target/usbhw_lpc.c ****     LPCUSB, an USB device driver for LPC microcontrollers   
   3:../common/lpcusb/target/usbhw_lpc.c ****     Copyright (C) 2006 Bertrik Sikken (bertrik@sikken.nl)
   4:../common/lpcusb/target/usbhw_lpc.c **** 
   5:../common/lpcusb/target/usbhw_lpc.c ****     Redistribution and use in source and binary forms, with or without
   6:../common/lpcusb/target/usbhw_lpc.c ****     modification, are permitted provided that the following conditions are met:
   7:../common/lpcusb/target/usbhw_lpc.c **** 
   8:../common/lpcusb/target/usbhw_lpc.c ****     1. Redistributions of source code must retain the above copyright
   9:../common/lpcusb/target/usbhw_lpc.c ****        notice, this list of conditions and the following disclaimer.
  10:../common/lpcusb/target/usbhw_lpc.c ****     2. Redistributions in binary form must reproduce the above copyright
  11:../common/lpcusb/target/usbhw_lpc.c ****        notice, this list of conditions and the following disclaimer in the
  12:../common/lpcusb/target/usbhw_lpc.c ****        documentation and/or other materials provided with the distribution.
  13:../common/lpcusb/target/usbhw_lpc.c ****     3. The name of the author may not be used to endorse or promote products
  14:../common/lpcusb/target/usbhw_lpc.c ****        derived from this software without specific prior written permission.
  15:../common/lpcusb/target/usbhw_lpc.c **** 
  16:../common/lpcusb/target/usbhw_lpc.c ****     THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  17:../common/lpcusb/target/usbhw_lpc.c ****     IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  18:../common/lpcusb/target/usbhw_lpc.c ****     OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  19:../common/lpcusb/target/usbhw_lpc.c ****     IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
  20:../common/lpcusb/target/usbhw_lpc.c ****     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  21:../common/lpcusb/target/usbhw_lpc.c ****     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  22:../common/lpcusb/target/usbhw_lpc.c ****     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  23:../common/lpcusb/target/usbhw_lpc.c ****     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24:../common/lpcusb/target/usbhw_lpc.c ****     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  25:../common/lpcusb/target/usbhw_lpc.c ****     THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26:../common/lpcusb/target/usbhw_lpc.c **** */
  27:../common/lpcusb/target/usbhw_lpc.c **** 
  28:../common/lpcusb/target/usbhw_lpc.c **** 
  29:../common/lpcusb/target/usbhw_lpc.c **** /** @file
  30:../common/lpcusb/target/usbhw_lpc.c ****     USB hardware layer
  31:../common/lpcusb/target/usbhw_lpc.c ****  */
  32:../common/lpcusb/target/usbhw_lpc.c **** 
  33:../common/lpcusb/target/usbhw_lpc.c **** #include "type.h"
ARM GAS  /tmp/cc3mLhQ4.s 			page 2


  34:../common/lpcusb/target/usbhw_lpc.c **** #include "debug.h"
  35:../common/lpcusb/target/usbhw_lpc.c **** 
  36:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC17xx
  37:../common/lpcusb/target/usbhw_lpc.c **** #include "lpc17.h"
  38:../common/lpcusb/target/usbhw_lpc.c **** #endif
  39:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC214x
  40:../common/lpcusb/target/usbhw_lpc.c **** #include "lpc214x.h"
  41:../common/lpcusb/target/usbhw_lpc.c **** #endif
  42:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC23xx
  43:../common/lpcusb/target/usbhw_lpc.c **** #include "lpc23xx.h"
  44:../common/lpcusb/target/usbhw_lpc.c **** #endif
  45:../common/lpcusb/target/usbhw_lpc.c **** #include "usbhw_lpc.h"
  46:../common/lpcusb/target/usbhw_lpc.c **** #include "usbapi.h"
  47:../common/lpcusb/target/usbhw_lpc.c **** 
  48:../common/lpcusb/target/usbhw_lpc.c **** 
  49:../common/lpcusb/target/usbhw_lpc.c **** #ifdef DEBUG
  50:../common/lpcusb/target/usbhw_lpc.c **** // comment out the following line if you don't want to use debug LEDs
  51:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED
  52:../common/lpcusb/target/usbhw_lpc.c **** #endif
  53:../common/lpcusb/target/usbhw_lpc.c **** 
  54:../common/lpcusb/target/usbhw_lpc.c **** #ifdef DEBUG_LED
  55:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC17xx
  56:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)
  57:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_ON(x)
  58:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)
  59:../common/lpcusb/target/usbhw_lpc.c **** #elif LPC214x
  60:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_ON(x)     IOCLR0 = (1 << x);
  61:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)    IOSET0 = (1 << x);
  62:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)   PINSEL0 &= ~(0x3 << (2*x)); IODIR0 |= (1 << x); DEBUG_LED_OFF(x);
  63:../common/lpcusb/target/usbhw_lpc.c **** #else
  64:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_ON(x)     FIO2SET = (1 << (x-8));
  65:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)    FIO2CLR = (1 << (x-8));
  66:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)   SCS |= 1; PINSEL10 = 0; FIO2DIR |= (1 << (x-8)); DEBUG_LED_OFF(x);
  67:../common/lpcusb/target/usbhw_lpc.c **** #endif
  68:../common/lpcusb/target/usbhw_lpc.c **** #else
  69:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)   /**< LED initialisation macro */
  70:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_ON(x)     /**< turn LED on */
  71:../common/lpcusb/target/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)    /**< turn LED off */
  72:../common/lpcusb/target/usbhw_lpc.c **** #endif
  73:../common/lpcusb/target/usbhw_lpc.c **** 
  74:../common/lpcusb/target/usbhw_lpc.c **** /** Installed device interrupt handler */
  75:../common/lpcusb/target/usbhw_lpc.c **** static TFnDevIntHandler *_pfnDevIntHandler = NULL;
  76:../common/lpcusb/target/usbhw_lpc.c **** /** Installed endpoint interrupt handlers */
  77:../common/lpcusb/target/usbhw_lpc.c **** static TFnEPIntHandler  *_apfnEPIntHandlers[16];
  78:../common/lpcusb/target/usbhw_lpc.c **** /** Installed frame interrupt handlers */
  79:../common/lpcusb/target/usbhw_lpc.c **** static TFnFrameHandler  *_pfnFrameHandler = NULL;
  80:../common/lpcusb/target/usbhw_lpc.c **** 
  81:../common/lpcusb/target/usbhw_lpc.c **** /** convert from endpoint address to endpoint index */
  82:../common/lpcusb/target/usbhw_lpc.c **** #define EP2IDX(bEP) ((((bEP)&0xF)<<1)|(((bEP)&0x80)>>7))
  83:../common/lpcusb/target/usbhw_lpc.c **** /** convert from endpoint index to endpoint address */
  84:../common/lpcusb/target/usbhw_lpc.c **** #define IDX2EP(idx) ((((idx)<<7)&0x80)|(((idx)>>1)&0xF))
  85:../common/lpcusb/target/usbhw_lpc.c **** 
  86:../common/lpcusb/target/usbhw_lpc.c **** 
  87:../common/lpcusb/target/usbhw_lpc.c **** 
  88:../common/lpcusb/target/usbhw_lpc.c **** /**
  89:../common/lpcusb/target/usbhw_lpc.c ****     Local function to wait for a device interrupt (and clear it)
  90:../common/lpcusb/target/usbhw_lpc.c ****         
ARM GAS  /tmp/cc3mLhQ4.s 			page 3


  91:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] dwIntr      Bitmask of interrupts to wait for   
  92:../common/lpcusb/target/usbhw_lpc.c ****  */
  93:../common/lpcusb/target/usbhw_lpc.c **** static void Wait4DevInt(U32 dwIntr)
  94:../common/lpcusb/target/usbhw_lpc.c **** {
  26              		.loc 1 94 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  32              	.L3:
  95:../common/lpcusb/target/usbhw_lpc.c ****     // wait for specific interrupt
  96:../common/lpcusb/target/usbhw_lpc.c ****     while ((USBDevIntSt & dwIntr) != dwIntr);
  33              		.loc 1 96 0 discriminator 1
  34 0000 034B     		ldr	r3, .L5
  35 0002 1B68     		ldr	r3, [r3]
  36 0004 0340     		ands	r3, r3, r0
  37 0006 8342     		cmp	r3, r0
  38 0008 FAD1     		bne	.L3
  97:../common/lpcusb/target/usbhw_lpc.c ****     // clear the interrupt bits
  98:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntClr = dwIntr;
  39              		.loc 1 98 0
  40 000a 024B     		ldr	r3, .L5+4
  41 000c 1860     		str	r0, [r3]
  42 000e 7047     		bx	lr
  43              	.L6:
  44              		.align	2
  45              	.L5:
  46 0010 00C20050 		.word	1342226944
  47 0014 08C20050 		.word	1342226952
  48              		.cfi_endproc
  49              	.LFE0:
  51              		.section	.text.USBHwCmd,"ax",%progbits
  52              		.align	1
  53              		.thumb
  54              		.thumb_func
  56              	USBHwCmd:
  57              	.LFB1:
  99:../common/lpcusb/target/usbhw_lpc.c **** }
 100:../common/lpcusb/target/usbhw_lpc.c **** 
 101:../common/lpcusb/target/usbhw_lpc.c **** 
 102:../common/lpcusb/target/usbhw_lpc.c **** /**
 103:../common/lpcusb/target/usbhw_lpc.c ****     Local function to send a command to the USB protocol engine
 104:../common/lpcusb/target/usbhw_lpc.c ****         
 105:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bCmd        Command to send
 106:../common/lpcusb/target/usbhw_lpc.c ****  */
 107:../common/lpcusb/target/usbhw_lpc.c **** static void USBHwCmd(U8 bCmd)
 108:../common/lpcusb/target/usbhw_lpc.c **** {
  58              		.loc 1 108 0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL1:
 109:../common/lpcusb/target/usbhw_lpc.c ****     // clear CDFULL/CCEMTY
 110:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntClr = CDFULL | CCEMTY;
  64              		.loc 1 110 0
ARM GAS  /tmp/cc3mLhQ4.s 			page 4


  65 0000 044B     		ldr	r3, .L8
 111:../common/lpcusb/target/usbhw_lpc.c ****     // write command code
 112:../common/lpcusb/target/usbhw_lpc.c ****     USBCmdCode = 0x00000500 | (bCmd << 16);
  66              		.loc 1 112 0
  67 0002 0004     		lsls	r0, r0, #16
  68              	.LVL2:
  69 0004 40F4A060 		orr	r0, r0, #1280
 110:../common/lpcusb/target/usbhw_lpc.c ****     // write command code
  70              		.loc 1 110 0
  71 0008 3022     		movs	r2, #48
  72 000a 1A60     		str	r2, [r3]
  73              		.loc 1 112 0
  74 000c 9860     		str	r0, [r3, #8]
 113:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CCEMTY);
  75              		.loc 1 113 0
  76 000e 1020     		movs	r0, #16
  77 0010 FFF7FEBF 		b	Wait4DevInt
  78              	.LVL3:
  79              	.L9:
  80              		.align	2
  81              	.L8:
  82 0014 08C20050 		.word	1342226952
  83              		.cfi_endproc
  84              	.LFE1:
  86              		.section	.text.USBHwCmdWrite,"ax",%progbits
  87              		.align	1
  88              		.thumb
  89              		.thumb_func
  91              	USBHwCmdWrite:
  92              	.LFB2:
 114:../common/lpcusb/target/usbhw_lpc.c **** }
 115:../common/lpcusb/target/usbhw_lpc.c **** 
 116:../common/lpcusb/target/usbhw_lpc.c **** 
 117:../common/lpcusb/target/usbhw_lpc.c **** /**
 118:../common/lpcusb/target/usbhw_lpc.c ****     Local function to send a command + data to the USB protocol engine
 119:../common/lpcusb/target/usbhw_lpc.c ****         
 120:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bCmd        Command to send
 121:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bData       Data to send
 122:../common/lpcusb/target/usbhw_lpc.c ****  */
 123:../common/lpcusb/target/usbhw_lpc.c **** static void USBHwCmdWrite(U8 bCmd, U16 bData)
 124:../common/lpcusb/target/usbhw_lpc.c **** {
  93              		.loc 1 124 0
  94              		.cfi_startproc
  95              		@ args = 0, pretend = 0, frame = 0
  96              		@ frame_needed = 0, uses_anonymous_args = 0
  97              	.LVL4:
  98 0000 10B5     		push	{r4, lr}
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 4, -8
 101              		.cfi_offset 14, -4
 102              		.loc 1 124 0
 103 0002 0C46     		mov	r4, r1
 125:../common/lpcusb/target/usbhw_lpc.c ****     // write command code
 126:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(bCmd);
 127:../common/lpcusb/target/usbhw_lpc.c **** 
 128:../common/lpcusb/target/usbhw_lpc.c ****     // write command data
 129:../common/lpcusb/target/usbhw_lpc.c ****     USBCmdCode = 0x00000100 | (bData << 16);
ARM GAS  /tmp/cc3mLhQ4.s 			page 5


 104              		.loc 1 129 0
 105 0004 2404     		lsls	r4, r4, #16
 126:../common/lpcusb/target/usbhw_lpc.c **** 
 106              		.loc 1 126 0
 107 0006 FFF7FEFF 		bl	USBHwCmd
 108              	.LVL5:
 109              		.loc 1 129 0
 110 000a 044B     		ldr	r3, .L11
 111 000c 44F48074 		orr	r4, r4, #256
 112 0010 1C60     		str	r4, [r3]
 130:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CCEMTY);
 113              		.loc 1 130 0
 114 0012 1020     		movs	r0, #16
 131:../common/lpcusb/target/usbhw_lpc.c **** }
 115              		.loc 1 131 0
 116 0014 BDE81040 		pop	{r4, lr}
 130:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CCEMTY);
 117              		.loc 1 130 0
 118 0018 FFF7FEBF 		b	Wait4DevInt
 119              	.LVL6:
 120              	.L12:
 121              		.align	2
 122              	.L11:
 123 001c 10C20050 		.word	1342226960
 124              		.cfi_endproc
 125              	.LFE2:
 127              		.section	.text.USBHwEPConfig,"ax",%progbits
 128              		.align	1
 129              		.global	USBHwEPConfig
 130              		.thumb
 131              		.thumb_func
 133              	USBHwEPConfig:
 134              	.LFB6:
 132:../common/lpcusb/target/usbhw_lpc.c **** 
 133:../common/lpcusb/target/usbhw_lpc.c **** 
 134:../common/lpcusb/target/usbhw_lpc.c **** /**
 135:../common/lpcusb/target/usbhw_lpc.c ****     Local function to send a command to the USB protocol engine and read data
 136:../common/lpcusb/target/usbhw_lpc.c ****         
 137:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bCmd        Command to send
 138:../common/lpcusb/target/usbhw_lpc.c **** 
 139:../common/lpcusb/target/usbhw_lpc.c ****     @return the data
 140:../common/lpcusb/target/usbhw_lpc.c ****  */
 141:../common/lpcusb/target/usbhw_lpc.c **** static U8 USBHwCmdRead(U8 bCmd)
 142:../common/lpcusb/target/usbhw_lpc.c **** {
 143:../common/lpcusb/target/usbhw_lpc.c ****     // write command code
 144:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(bCmd);
 145:../common/lpcusb/target/usbhw_lpc.c ****     
 146:../common/lpcusb/target/usbhw_lpc.c ****     // get data
 147:../common/lpcusb/target/usbhw_lpc.c ****     USBCmdCode = 0x00000200 | (bCmd << 16);
 148:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CDFULL);
 149:../common/lpcusb/target/usbhw_lpc.c ****     return USBCmdData;
 150:../common/lpcusb/target/usbhw_lpc.c **** }
 151:../common/lpcusb/target/usbhw_lpc.c **** 
 152:../common/lpcusb/target/usbhw_lpc.c **** 
 153:../common/lpcusb/target/usbhw_lpc.c **** /**
 154:../common/lpcusb/target/usbhw_lpc.c ****     'Realizes' an endpoint, meaning that buffer space is reserved for
 155:../common/lpcusb/target/usbhw_lpc.c ****     it. An endpoint needs to be realised before it can be used.
ARM GAS  /tmp/cc3mLhQ4.s 			page 6


 156:../common/lpcusb/target/usbhw_lpc.c ****         
 157:../common/lpcusb/target/usbhw_lpc.c ****     From experiments, it appears that a USB reset causes USBReEp to
 158:../common/lpcusb/target/usbhw_lpc.c ****     re-initialise to 3 (= just the control endpoints).
 159:../common/lpcusb/target/usbhw_lpc.c ****     However, a USB bus reset does not disturb the USBMaxPSize settings.
 160:../common/lpcusb/target/usbhw_lpc.c ****         
 161:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] idx         Endpoint index
 162:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] wMaxPSize   Maximum packet size for this endpoint
 163:../common/lpcusb/target/usbhw_lpc.c ****  */
 164:../common/lpcusb/target/usbhw_lpc.c **** static void USBHwEPRealize(int idx, U16 wMaxPSize)
 165:../common/lpcusb/target/usbhw_lpc.c **** {
 166:../common/lpcusb/target/usbhw_lpc.c ****     USBReEp |= (1 << idx);
 167:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC17xx
 168:../common/lpcusb/target/usbhw_lpc.c ****     USBEpIn = idx;
 169:../common/lpcusb/target/usbhw_lpc.c **** #else
 170:../common/lpcusb/target/usbhw_lpc.c ****     USBEpInd = idx;
 171:../common/lpcusb/target/usbhw_lpc.c **** #endif
 172:../common/lpcusb/target/usbhw_lpc.c ****     USBMaxPSize = wMaxPSize;
 173:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(EP_RLZED);
 174:../common/lpcusb/target/usbhw_lpc.c **** }
 175:../common/lpcusb/target/usbhw_lpc.c **** 
 176:../common/lpcusb/target/usbhw_lpc.c **** 
 177:../common/lpcusb/target/usbhw_lpc.c **** /**
 178:../common/lpcusb/target/usbhw_lpc.c ****     Enables or disables an endpoint
 179:../common/lpcusb/target/usbhw_lpc.c ****         
 180:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] idx     Endpoint index
 181:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] fEnable TRUE to enable, FALSE to disable
 182:../common/lpcusb/target/usbhw_lpc.c ****  */
 183:../common/lpcusb/target/usbhw_lpc.c **** static void USBHwEPEnable(int idx, BOOL fEnable)
 184:../common/lpcusb/target/usbhw_lpc.c **** {
 185:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
 186:../common/lpcusb/target/usbhw_lpc.c **** }
 187:../common/lpcusb/target/usbhw_lpc.c **** 
 188:../common/lpcusb/target/usbhw_lpc.c **** 
 189:../common/lpcusb/target/usbhw_lpc.c **** /**
 190:../common/lpcusb/target/usbhw_lpc.c ****     Configures an endpoint and enables it
 191:../common/lpcusb/target/usbhw_lpc.c ****         
 192:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEP             Endpoint number
 193:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] wMaxPacketSize  Maximum packet size for this EP
 194:../common/lpcusb/target/usbhw_lpc.c ****  */
 195:../common/lpcusb/target/usbhw_lpc.c **** void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
 196:../common/lpcusb/target/usbhw_lpc.c **** {
 135              		.loc 1 196 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              	.LVL7:
 140 0000 10B5     		push	{r4, lr}
 141              		.cfi_def_cfa_offset 8
 142              		.cfi_offset 4, -8
 143              		.cfi_offset 14, -4
 197:../common/lpcusb/target/usbhw_lpc.c ****     int idx;
 198:../common/lpcusb/target/usbhw_lpc.c ****     
 199:../common/lpcusb/target/usbhw_lpc.c ****     idx = EP2IDX(bEP);
 144              		.loc 1 199 0
 145 0002 00F00F04 		and	r4, r0, #15
 146 0006 C009     		lsrs	r0, r0, #7
 147              	.LVL8:
ARM GAS  /tmp/cc3mLhQ4.s 			page 7


 148 0008 40EA4404 		orr	r4, r0, r4, lsl #1
 149              	.LVL9:
 150              	.LBB6:
 151              	.LBB7:
 166:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC17xx
 152              		.loc 1 166 0
 153 000c 0122     		movs	r2, #1
 154 000e A240     		lsls	r2, r2, r4
 155 0010 084B     		ldr	r3, .L14
 156 0012 1868     		ldr	r0, [r3]
 157 0014 0243     		orrs	r2, r2, r0
 158 0016 1A60     		str	r2, [r3]
 173:../common/lpcusb/target/usbhw_lpc.c **** }
 159              		.loc 1 173 0
 160 0018 4FF48070 		mov	r0, #256
 168:../common/lpcusb/target/usbhw_lpc.c **** #else
 161              		.loc 1 168 0
 162 001c 5C60     		str	r4, [r3, #4]
 172:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(EP_RLZED);
 163              		.loc 1 172 0
 164 001e 9960     		str	r1, [r3, #8]
 173:../common/lpcusb/target/usbhw_lpc.c **** }
 165              		.loc 1 173 0
 166 0020 FFF7FEFF 		bl	Wait4DevInt
 167              	.LVL10:
 168              	.LBE7:
 169              	.LBE6:
 170              	.LBB8:
 171              	.LBB9:
 185:../common/lpcusb/target/usbhw_lpc.c **** }
 172              		.loc 1 185 0
 173 0024 44F04000 		orr	r0, r4, #64
 174 0028 0021     		movs	r1, #0
 175              	.LBE9:
 176              	.LBE8:
 200:../common/lpcusb/target/usbhw_lpc.c ****     
 201:../common/lpcusb/target/usbhw_lpc.c ****     // realise EP
 202:../common/lpcusb/target/usbhw_lpc.c ****     USBHwEPRealize(idx, wMaxPacketSize);
 203:../common/lpcusb/target/usbhw_lpc.c **** 
 204:../common/lpcusb/target/usbhw_lpc.c ****     // enable EP
 205:../common/lpcusb/target/usbhw_lpc.c ****     USBHwEPEnable(idx, TRUE);
 206:../common/lpcusb/target/usbhw_lpc.c **** }
 177              		.loc 1 206 0
 178 002a BDE81040 		pop	{r4, lr}
 179              	.LVL11:
 180              	.LBB11:
 181              	.LBB10:
 185:../common/lpcusb/target/usbhw_lpc.c **** }
 182              		.loc 1 185 0
 183 002e FFF7FEBF 		b	USBHwCmdWrite
 184              	.LVL12:
 185              	.L15:
 186 0032 00BF     		.align	2
 187              	.L14:
 188 0034 44C20050 		.word	1342227012
 189              	.LBE10:
 190              	.LBE11:
ARM GAS  /tmp/cc3mLhQ4.s 			page 8


 191              		.cfi_endproc
 192              	.LFE6:
 194              		.section	.text.USBHwRegisterEPIntHandler,"ax",%progbits
 195              		.align	1
 196              		.global	USBHwRegisterEPIntHandler
 197              		.thumb
 198              		.thumb_func
 200              	USBHwRegisterEPIntHandler:
 201              	.LFB7:
 207:../common/lpcusb/target/usbhw_lpc.c **** 
 208:../common/lpcusb/target/usbhw_lpc.c **** 
 209:../common/lpcusb/target/usbhw_lpc.c **** /**
 210:../common/lpcusb/target/usbhw_lpc.c ****     Registers an endpoint event callback
 211:../common/lpcusb/target/usbhw_lpc.c ****         
 212:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEP             Endpoint number
 213:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] pfnHandler      Callback function
 214:../common/lpcusb/target/usbhw_lpc.c ****  */
 215:../common/lpcusb/target/usbhw_lpc.c **** void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
 216:../common/lpcusb/target/usbhw_lpc.c **** {
 202              		.loc 1 216 0
 203              		.cfi_startproc
 204              		@ args = 0, pretend = 0, frame = 0
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              		@ link register save eliminated.
 207              	.LVL13:
 217:../common/lpcusb/target/usbhw_lpc.c ****     int idx;
 218:../common/lpcusb/target/usbhw_lpc.c ****     
 219:../common/lpcusb/target/usbhw_lpc.c ****     idx = EP2IDX(bEP);
 220:../common/lpcusb/target/usbhw_lpc.c **** 
 221:../common/lpcusb/target/usbhw_lpc.c ****     ASSERT(idx<32);
 222:../common/lpcusb/target/usbhw_lpc.c **** 
 223:../common/lpcusb/target/usbhw_lpc.c ****     /* add handler to list of EP handlers */
 224:../common/lpcusb/target/usbhw_lpc.c ****     _apfnEPIntHandlers[idx / 2] = pfnHandler;
 208              		.loc 1 224 0
 209 0000 0A4A     		ldr	r2, .L17
 219:../common/lpcusb/target/usbhw_lpc.c **** 
 210              		.loc 1 219 0
 211 0002 00F00F03 		and	r3, r0, #15
 212 0006 C009     		lsrs	r0, r0, #7
 213              	.LVL14:
 214              		.loc 1 224 0
 215 0008 42F82310 		str	r1, [r2, r3, lsl #2]
 216 000c 40EA4300 		orr	r0, r0, r3, lsl #1
 217              	.LVL15:
 225:../common/lpcusb/target/usbhw_lpc.c ****     
 226:../common/lpcusb/target/usbhw_lpc.c ****     /* enable EP interrupt */
 227:../common/lpcusb/target/usbhw_lpc.c ****     USBEpIntEn |= (1 << idx);
 218              		.loc 1 227 0
 219 0010 0121     		movs	r1, #1
 220              	.LVL16:
 221 0012 01FA00F0 		lsl	r0, r1, r0
 222              	.LVL17:
 223 0016 064B     		ldr	r3, .L17+4
 224              	.LVL18:
 225 0018 1A68     		ldr	r2, [r3]
 226 001a 1043     		orrs	r0, r0, r2
 227 001c 1860     		str	r0, [r3]
ARM GAS  /tmp/cc3mLhQ4.s 			page 9


 228:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntEn |= EP_SLOW;
 228              		.loc 1 228 0
 229 001e 53F8302C 		ldr	r2, [r3, #-48]
 230 0022 42F00402 		orr	r2, r2, #4
 231 0026 43F8302C 		str	r2, [r3, #-48]
 232 002a 7047     		bx	lr
 233              	.L18:
 234              		.align	2
 235              	.L17:
 236 002c 00000000 		.word	.LANCHOR0
 237 0030 34C20050 		.word	1342226996
 238              		.cfi_endproc
 239              	.LFE7:
 241              		.section	.text.USBHwRegisterDevIntHandler,"ax",%progbits
 242              		.align	1
 243              		.global	USBHwRegisterDevIntHandler
 244              		.thumb
 245              		.thumb_func
 247              	USBHwRegisterDevIntHandler:
 248              	.LFB8:
 229:../common/lpcusb/target/usbhw_lpc.c ****     
 230:../common/lpcusb/target/usbhw_lpc.c ****     DBG("Registered handler for EP 0x%x\n", bEP);
 231:../common/lpcusb/target/usbhw_lpc.c **** }
 232:../common/lpcusb/target/usbhw_lpc.c **** 
 233:../common/lpcusb/target/usbhw_lpc.c **** 
 234:../common/lpcusb/target/usbhw_lpc.c **** /**
 235:../common/lpcusb/target/usbhw_lpc.c ****     Registers an device status callback
 236:../common/lpcusb/target/usbhw_lpc.c ****         
 237:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] pfnHandler  Callback function
 238:../common/lpcusb/target/usbhw_lpc.c ****  */
 239:../common/lpcusb/target/usbhw_lpc.c **** void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
 240:../common/lpcusb/target/usbhw_lpc.c **** {
 249              		.loc 1 240 0
 250              		.cfi_startproc
 251              		@ args = 0, pretend = 0, frame = 0
 252              		@ frame_needed = 0, uses_anonymous_args = 0
 253              		@ link register save eliminated.
 254              	.LVL19:
 241:../common/lpcusb/target/usbhw_lpc.c ****     _pfnDevIntHandler = pfnHandler;
 255              		.loc 1 241 0
 256 0000 034B     		ldr	r3, .L20
 257 0002 1864     		str	r0, [r3, #64]
 242:../common/lpcusb/target/usbhw_lpc.c ****     
 243:../common/lpcusb/target/usbhw_lpc.c ****     // enable device interrupt
 244:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntEn |= DEV_STAT;
 258              		.loc 1 244 0
 259 0004 034B     		ldr	r3, .L20+4
 260 0006 1A68     		ldr	r2, [r3]
 261 0008 42F00802 		orr	r2, r2, #8
 262 000c 1A60     		str	r2, [r3]
 263 000e 7047     		bx	lr
 264              	.L21:
 265              		.align	2
 266              	.L20:
 267 0010 00000000 		.word	.LANCHOR0
 268 0014 04C20050 		.word	1342226948
 269              		.cfi_endproc
ARM GAS  /tmp/cc3mLhQ4.s 			page 10


 270              	.LFE8:
 272              		.section	.text.USBHwRegisterFrameHandler,"ax",%progbits
 273              		.align	1
 274              		.global	USBHwRegisterFrameHandler
 275              		.thumb
 276              		.thumb_func
 278              	USBHwRegisterFrameHandler:
 279              	.LFB9:
 245:../common/lpcusb/target/usbhw_lpc.c **** 
 246:../common/lpcusb/target/usbhw_lpc.c ****     DBG("Registered handler for device status\n");
 247:../common/lpcusb/target/usbhw_lpc.c **** }
 248:../common/lpcusb/target/usbhw_lpc.c **** 
 249:../common/lpcusb/target/usbhw_lpc.c **** 
 250:../common/lpcusb/target/usbhw_lpc.c **** /**
 251:../common/lpcusb/target/usbhw_lpc.c ****     Registers the frame callback
 252:../common/lpcusb/target/usbhw_lpc.c ****         
 253:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] pfnHandler  Callback function
 254:../common/lpcusb/target/usbhw_lpc.c ****  */
 255:../common/lpcusb/target/usbhw_lpc.c **** void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
 256:../common/lpcusb/target/usbhw_lpc.c **** {
 280              		.loc 1 256 0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 0
 283              		@ frame_needed = 0, uses_anonymous_args = 0
 284              		@ link register save eliminated.
 285              	.LVL20:
 257:../common/lpcusb/target/usbhw_lpc.c ****     _pfnFrameHandler = pfnHandler;
 286              		.loc 1 257 0
 287 0000 034B     		ldr	r3, .L23
 288 0002 5864     		str	r0, [r3, #68]
 258:../common/lpcusb/target/usbhw_lpc.c ****     
 259:../common/lpcusb/target/usbhw_lpc.c ****     // enable device interrupt
 260:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntEn |= FRAME;
 289              		.loc 1 260 0
 290 0004 034B     		ldr	r3, .L23+4
 291 0006 1A68     		ldr	r2, [r3]
 292 0008 42F00102 		orr	r2, r2, #1
 293 000c 1A60     		str	r2, [r3]
 294 000e 7047     		bx	lr
 295              	.L24:
 296              		.align	2
 297              	.L23:
 298 0010 00000000 		.word	.LANCHOR0
 299 0014 04C20050 		.word	1342226948
 300              		.cfi_endproc
 301              	.LFE9:
 303              		.section	.text.USBHwSetAddress,"ax",%progbits
 304              		.align	1
 305              		.global	USBHwSetAddress
 306              		.thumb
 307              		.thumb_func
 309              	USBHwSetAddress:
 310              	.LFB10:
 261:../common/lpcusb/target/usbhw_lpc.c **** 
 262:../common/lpcusb/target/usbhw_lpc.c ****     DBG("Registered handler for frame\n");
 263:../common/lpcusb/target/usbhw_lpc.c **** }
 264:../common/lpcusb/target/usbhw_lpc.c **** 
ARM GAS  /tmp/cc3mLhQ4.s 			page 11


 265:../common/lpcusb/target/usbhw_lpc.c **** 
 266:../common/lpcusb/target/usbhw_lpc.c **** /**
 267:../common/lpcusb/target/usbhw_lpc.c ****     Sets the USB address.
 268:../common/lpcusb/target/usbhw_lpc.c ****         
 269:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bAddr       Device address to set
 270:../common/lpcusb/target/usbhw_lpc.c ****  */
 271:../common/lpcusb/target/usbhw_lpc.c **** void USBHwSetAddress(U8 bAddr)
 272:../common/lpcusb/target/usbhw_lpc.c **** {
 311              		.loc 1 272 0
 312              		.cfi_startproc
 313              		@ args = 0, pretend = 0, frame = 0
 314              		@ frame_needed = 0, uses_anonymous_args = 0
 315              		@ link register save eliminated.
 316              	.LVL21:
 273:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
 317              		.loc 1 273 0
 318 0000 40F08001 		orr	r1, r0, #128
 319 0004 D020     		movs	r0, #208
 320              	.LVL22:
 321 0006 FFF7FEBF 		b	USBHwCmdWrite
 322              	.LVL23:
 323              		.cfi_endproc
 324              	.LFE10:
 326              		.section	.text.USBHwConnect,"ax",%progbits
 327              		.align	1
 328              		.global	USBHwConnect
 329              		.thumb
 330              		.thumb_func
 332              	USBHwConnect:
 333              	.LFB11:
 274:../common/lpcusb/target/usbhw_lpc.c **** }
 275:../common/lpcusb/target/usbhw_lpc.c **** 
 276:../common/lpcusb/target/usbhw_lpc.c **** 
 277:../common/lpcusb/target/usbhw_lpc.c **** /**
 278:../common/lpcusb/target/usbhw_lpc.c ****     Connects or disconnects from the USB bus
 279:../common/lpcusb/target/usbhw_lpc.c ****         
 280:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] fConnect    If TRUE, connect, otherwise disconnect
 281:../common/lpcusb/target/usbhw_lpc.c ****  */
 282:../common/lpcusb/target/usbhw_lpc.c **** void USBHwConnect(BOOL fConnect)
 283:../common/lpcusb/target/usbhw_lpc.c **** {
 334              		.loc 1 283 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              		@ link register save eliminated.
 339              	.LVL24:
 284:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC23xx
 285:../common/lpcusb/target/usbhw_lpc.c **** #ifndef LPC2378_PORTB
 286:../common/lpcusb/target/usbhw_lpc.c ****   if(fConnect)
 287:../common/lpcusb/target/usbhw_lpc.c ****     FIO2CLR = (1<<9);
 288:../common/lpcusb/target/usbhw_lpc.c ****   else
 289:../common/lpcusb/target/usbhw_lpc.c ****     FIO2SET = (1<<9);
 290:../common/lpcusb/target/usbhw_lpc.c **** #else
 291:../common/lpcusb/target/usbhw_lpc.c ****   if(fConnect)
 292:../common/lpcusb/target/usbhw_lpc.c ****     FIO0CLR = (1<<14);
 293:../common/lpcusb/target/usbhw_lpc.c ****   else
 294:../common/lpcusb/target/usbhw_lpc.c ****     FIO0SET = (1<<14);
ARM GAS  /tmp/cc3mLhQ4.s 			page 12


 295:../common/lpcusb/target/usbhw_lpc.c **** #endif
 296:../common/lpcusb/target/usbhw_lpc.c **** #endif
 297:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
 340              		.loc 1 297 0
 341 0000 011C     		adds	r1, r0, #0
 342 0002 18BF     		it	ne
 343 0004 0121     		movne	r1, #1
 344 0006 FE20     		movs	r0, #254
 345              	.LVL25:
 346 0008 FFF7FEBF 		b	USBHwCmdWrite
 347              	.LVL26:
 348              		.cfi_endproc
 349              	.LFE11:
 351              		.section	.text.USBHwNakIntEnable,"ax",%progbits
 352              		.align	1
 353              		.global	USBHwNakIntEnable
 354              		.thumb
 355              		.thumb_func
 357              	USBHwNakIntEnable:
 358              	.LFB12:
 298:../common/lpcusb/target/usbhw_lpc.c **** }
 299:../common/lpcusb/target/usbhw_lpc.c **** 
 300:../common/lpcusb/target/usbhw_lpc.c **** 
 301:../common/lpcusb/target/usbhw_lpc.c **** /**
 302:../common/lpcusb/target/usbhw_lpc.c ****     Enables interrupt on NAK condition
 303:../common/lpcusb/target/usbhw_lpc.c ****         
 304:../common/lpcusb/target/usbhw_lpc.c ****     For IN endpoints a NAK is generated when the host wants to read data
 305:../common/lpcusb/target/usbhw_lpc.c ****     from the device, but none is available in the endpoint buffer.
 306:../common/lpcusb/target/usbhw_lpc.c ****     For OUT endpoints a NAK is generated when the host wants to write data
 307:../common/lpcusb/target/usbhw_lpc.c ****     to the device, but the endpoint buffer is still full.
 308:../common/lpcusb/target/usbhw_lpc.c ****     
 309:../common/lpcusb/target/usbhw_lpc.c ****     The endpoint interrupt handlers can distinguish regular (ACK) interrupts
 310:../common/lpcusb/target/usbhw_lpc.c ****     from NAK interrupt by checking the bits in their bEPStatus argument.
 311:../common/lpcusb/target/usbhw_lpc.c ****     
 312:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bIntBits    Bitmap indicating which NAK interrupts to enable
 313:../common/lpcusb/target/usbhw_lpc.c ****  */
 314:../common/lpcusb/target/usbhw_lpc.c **** void USBHwNakIntEnable(U8 bIntBits)
 315:../common/lpcusb/target/usbhw_lpc.c **** {
 359              		.loc 1 315 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363              		@ link register save eliminated.
 364              	.LVL27:
 365              		.loc 1 315 0
 366 0000 0146     		mov	r1, r0
 316:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
 367              		.loc 1 316 0
 368 0002 F320     		movs	r0, #243
 369              	.LVL28:
 370 0004 FFF7FEBF 		b	USBHwCmdWrite
 371              	.LVL29:
 372              		.cfi_endproc
 373              	.LFE12:
 375              		.section	.text.USBHwEPGetStatus,"ax",%progbits
 376              		.align	1
 377              		.global	USBHwEPGetStatus
ARM GAS  /tmp/cc3mLhQ4.s 			page 13


 378              		.thumb
 379              		.thumb_func
 381              	USBHwEPGetStatus:
 382              	.LFB13:
 317:../common/lpcusb/target/usbhw_lpc.c **** }
 318:../common/lpcusb/target/usbhw_lpc.c **** 
 319:../common/lpcusb/target/usbhw_lpc.c **** 
 320:../common/lpcusb/target/usbhw_lpc.c **** /**
 321:../common/lpcusb/target/usbhw_lpc.c ****     Gets the status from a specific endpoint.
 322:../common/lpcusb/target/usbhw_lpc.c ****         
 323:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEP     Endpoint number
 324:../common/lpcusb/target/usbhw_lpc.c ****     @return Endpoint status byte (containing EP_STATUS_xxx bits)
 325:../common/lpcusb/target/usbhw_lpc.c ****  */
 326:../common/lpcusb/target/usbhw_lpc.c **** U8  USBHwEPGetStatus(U8 bEP)
 327:../common/lpcusb/target/usbhw_lpc.c **** {
 383              		.loc 1 327 0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 0
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              	.LVL30:
 388 0000 10B5     		push	{r4, lr}
 389              		.cfi_def_cfa_offset 8
 390              		.cfi_offset 4, -8
 391              		.cfi_offset 14, -4
 328:../common/lpcusb/target/usbhw_lpc.c ****     int idx = EP2IDX(bEP);
 392              		.loc 1 328 0
 393 0002 00F00F04 		and	r4, r0, #15
 394 0006 C009     		lsrs	r0, r0, #7
 395              	.LVL31:
 396 0008 40EA4404 		orr	r4, r0, r4, lsl #1
 397              	.LVL32:
 398              	.LBB14:
 399              	.LBB15:
 144:../common/lpcusb/target/usbhw_lpc.c ****     
 400              		.loc 1 144 0
 401 000c 2046     		mov	r0, r4
 402 000e FFF7FEFF 		bl	USBHwCmd
 403              	.LVL33:
 147:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CDFULL);
 404              		.loc 1 147 0
 405 0012 2404     		lsls	r4, r4, #16
 406              	.LVL34:
 407 0014 054B     		ldr	r3, .L29
 408 0016 44F40074 		orr	r4, r4, #512
 409 001a 1C60     		str	r4, [r3]
 148:../common/lpcusb/target/usbhw_lpc.c ****     return USBCmdData;
 410              		.loc 1 148 0
 411 001c 2020     		movs	r0, #32
 412 001e FFF7FEFF 		bl	Wait4DevInt
 413              	.LVL35:
 149:../common/lpcusb/target/usbhw_lpc.c **** }
 414              		.loc 1 149 0
 415 0022 034B     		ldr	r3, .L29+4
 416 0024 1868     		ldr	r0, [r3]
 417              	.LBE15:
 418              	.LBE14:
 329:../common/lpcusb/target/usbhw_lpc.c **** 
ARM GAS  /tmp/cc3mLhQ4.s 			page 14


 330:../common/lpcusb/target/usbhw_lpc.c ****     return USBHwCmdRead(CMD_EP_SELECT | idx);
 331:../common/lpcusb/target/usbhw_lpc.c **** }
 419              		.loc 1 331 0
 420 0026 C0B2     		uxtb	r0, r0
 421 0028 10BD     		pop	{r4, pc}
 422              	.L30:
 423 002a 00BF     		.align	2
 424              	.L29:
 425 002c 10C20050 		.word	1342226960
 426 0030 14C20050 		.word	1342226964
 427              		.cfi_endproc
 428              	.LFE13:
 430              		.section	.text.USBHwEPStall,"ax",%progbits
 431              		.align	1
 432              		.global	USBHwEPStall
 433              		.thumb
 434              		.thumb_func
 436              	USBHwEPStall:
 437              	.LFB14:
 332:../common/lpcusb/target/usbhw_lpc.c **** 
 333:../common/lpcusb/target/usbhw_lpc.c **** 
 334:../common/lpcusb/target/usbhw_lpc.c **** /**
 335:../common/lpcusb/target/usbhw_lpc.c ****     Sets the stalled property of an endpoint
 336:../common/lpcusb/target/usbhw_lpc.c ****         
 337:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEP     Endpoint number
 338:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] fStall  TRUE to stall, FALSE to unstall
 339:../common/lpcusb/target/usbhw_lpc.c ****  */
 340:../common/lpcusb/target/usbhw_lpc.c **** void USBHwEPStall(U8 bEP, BOOL fStall)
 341:../common/lpcusb/target/usbhw_lpc.c **** {
 438              		.loc 1 341 0
 439              		.cfi_startproc
 440              		@ args = 0, pretend = 0, frame = 0
 441              		@ frame_needed = 0, uses_anonymous_args = 0
 442              		@ link register save eliminated.
 443              	.LVL36:
 444              	.LVL37:
 342:../common/lpcusb/target/usbhw_lpc.c ****     int idx = EP2IDX(bEP);
 445              		.loc 1 342 0
 446 0000 00F00F03 		and	r3, r0, #15
 447 0004 C009     		lsrs	r0, r0, #7
 448              	.LVL38:
 449 0006 40EA4300 		orr	r0, r0, r3, lsl #1
 343:../common/lpcusb/target/usbhw_lpc.c **** 
 344:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
 450              		.loc 1 344 0
 451 000a 0031     		adds	r1, r1, #0
 452 000c 40F04000 		orr	r0, r0, #64
 453 0010 18BF     		it	ne
 454 0012 0121     		movne	r1, #1
 455              	.LVL39:
 456 0014 FFF7FEBF 		b	USBHwCmdWrite
 457              	.LVL40:
 458              		.cfi_endproc
 459              	.LFE14:
 461              		.section	.text.USBHwEPWrite,"ax",%progbits
 462              		.align	1
 463              		.global	USBHwEPWrite
ARM GAS  /tmp/cc3mLhQ4.s 			page 15


 464              		.thumb
 465              		.thumb_func
 467              	USBHwEPWrite:
 468              	.LFB15:
 345:../common/lpcusb/target/usbhw_lpc.c **** }
 346:../common/lpcusb/target/usbhw_lpc.c **** 
 347:../common/lpcusb/target/usbhw_lpc.c **** 
 348:../common/lpcusb/target/usbhw_lpc.c **** /**
 349:../common/lpcusb/target/usbhw_lpc.c ****     Writes data to an endpoint buffer
 350:../common/lpcusb/target/usbhw_lpc.c ****         
 351:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEP     Endpoint number
 352:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] pbBuf   Endpoint data
 353:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] iLen    Number of bytes to write
 354:../common/lpcusb/target/usbhw_lpc.c ****             
 355:../common/lpcusb/target/usbhw_lpc.c ****     @return number of bytes written into the endpoint buffer
 356:../common/lpcusb/target/usbhw_lpc.c **** */
 357:../common/lpcusb/target/usbhw_lpc.c **** int USBHwEPWrite(U8 bEP, U8 *pbBuf, U32 iLen)
 358:../common/lpcusb/target/usbhw_lpc.c **** {
 469              		.loc 1 358 0
 470              		.cfi_startproc
 471              		@ args = 0, pretend = 0, frame = 0
 472              		@ frame_needed = 0, uses_anonymous_args = 0
 473              	.LVL41:
 474 0000 10B5     		push	{r4, lr}
 475              		.cfi_def_cfa_offset 8
 476              		.cfi_offset 4, -8
 477              		.cfi_offset 14, -4
 359:../common/lpcusb/target/usbhw_lpc.c ****     U32 idx;
 360:../common/lpcusb/target/usbhw_lpc.c ****     
 361:../common/lpcusb/target/usbhw_lpc.c ****     idx = EP2IDX(bEP);
 478              		.loc 1 361 0
 479 0002 00F00F03 		and	r3, r0, #15
 480 0006 C009     		lsrs	r0, r0, #7
 481              	.LVL42:
 358:../common/lpcusb/target/usbhw_lpc.c ****     U32 idx;
 482              		.loc 1 358 0
 483 0008 1446     		mov	r4, r2
 484              		.loc 1 361 0
 485 000a 40EA4300 		orr	r0, r0, r3, lsl #1
 486              	.LVL43:
 362:../common/lpcusb/target/usbhw_lpc.c ****     
 363:../common/lpcusb/target/usbhw_lpc.c ****     // set write enable for specific endpoint
 364:../common/lpcusb/target/usbhw_lpc.c ****     USBCtrl = WR_EN | ((bEP & 0xF) << 2);
 487              		.loc 1 364 0
 488 000e 114A     		ldr	r2, .L36
 489              	.LVL44:
 490 0010 9B00     		lsls	r3, r3, #2
 491 0012 43F00203 		orr	r3, r3, #2
 492 0016 1360     		str	r3, [r2]
 365:../common/lpcusb/target/usbhw_lpc.c ****     
 366:../common/lpcusb/target/usbhw_lpc.c ****     // set packet length
 367:../common/lpcusb/target/usbhw_lpc.c ****     USBTxPLen = iLen;
 493              		.loc 1 367 0
 494 0018 0F4B     		ldr	r3, .L36+4
 495 001a 1C60     		str	r4, [r3]
 496              	.L33:
 368:../common/lpcusb/target/usbhw_lpc.c ****     
ARM GAS  /tmp/cc3mLhQ4.s 			page 16


 369:../common/lpcusb/target/usbhw_lpc.c ****     // write data
 370:../common/lpcusb/target/usbhw_lpc.c ****     while (USBCtrl & WR_EN) {
 497              		.loc 1 370 0 discriminator 1
 498 001c 0D4B     		ldr	r3, .L36
 499 001e 1A68     		ldr	r2, [r3]
 500 0020 12F00202 		ands	r2, r2, #2
 501 0024 0ED0     		beq	.L35
 371:../common/lpcusb/target/usbhw_lpc.c ****         USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
 502              		.loc 1 371 0
 503 0026 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
 504 0028 CB78     		ldrb	r3, [r1, #3]	@ zero_extendqisi2
 505 002a 1204     		lsls	r2, r2, #16
 506 002c 42EA0362 		orr	r2, r2, r3, lsl #24
 507 0030 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 372:../common/lpcusb/target/usbhw_lpc.c ****         pbBuf += 4;
 508              		.loc 1 372 0
 509 0032 0431     		adds	r1, r1, #4
 510              	.LVL45:
 371:../common/lpcusb/target/usbhw_lpc.c ****         USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
 511              		.loc 1 371 0
 512 0034 1A43     		orrs	r2, r2, r3
 513 0036 11F8033C 		ldrb	r3, [r1, #-3]	@ zero_extendqisi2
 514              	.LVL46:
 515 003a 42EA0322 		orr	r2, r2, r3, lsl #8
 516 003e 074B     		ldr	r3, .L36+8
 517 0040 1A60     		str	r2, [r3]
 518 0042 EBE7     		b	.L33
 519              	.L35:
 373:../common/lpcusb/target/usbhw_lpc.c ****     }
 374:../common/lpcusb/target/usbhw_lpc.c **** 
 375:../common/lpcusb/target/usbhw_lpc.c ****     USBCtrl = 0;
 520              		.loc 1 375 0
 521 0044 1A60     		str	r2, [r3]
 376:../common/lpcusb/target/usbhw_lpc.c **** 
 377:../common/lpcusb/target/usbhw_lpc.c ****     // select endpoint and validate buffer
 378:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(CMD_EP_SELECT | idx);
 522              		.loc 1 378 0
 523 0046 FFF7FEFF 		bl	USBHwCmd
 524              	.LVL47:
 379:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(CMD_EP_VALIDATE_BUFFER);
 525              		.loc 1 379 0
 526 004a FA20     		movs	r0, #250
 527 004c FFF7FEFF 		bl	USBHwCmd
 528              	.LVL48:
 380:../common/lpcusb/target/usbhw_lpc.c ****     
 381:../common/lpcusb/target/usbhw_lpc.c ****     return iLen;
 382:../common/lpcusb/target/usbhw_lpc.c **** }
 529              		.loc 1 382 0
 530 0050 2046     		mov	r0, r4
 531 0052 10BD     		pop	{r4, pc}
 532              	.LVL49:
 533              	.L37:
 534              		.align	2
 535              	.L36:
 536 0054 28C20050 		.word	1342226984
 537 0058 24C20050 		.word	1342226980
 538 005c 1CC20050 		.word	1342226972
ARM GAS  /tmp/cc3mLhQ4.s 			page 17


 539              		.cfi_endproc
 540              	.LFE15:
 542              		.section	.text.USBHwEPRead,"ax",%progbits
 543              		.align	1
 544              		.global	USBHwEPRead
 545              		.thumb
 546              		.thumb_func
 548              	USBHwEPRead:
 549              	.LFB16:
 383:../common/lpcusb/target/usbhw_lpc.c **** 
 384:../common/lpcusb/target/usbhw_lpc.c **** 
 385:../common/lpcusb/target/usbhw_lpc.c **** /**
 386:../common/lpcusb/target/usbhw_lpc.c ****     Reads data from an endpoint buffer
 387:../common/lpcusb/target/usbhw_lpc.c ****         
 388:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEP     Endpoint number
 389:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] pbBuf   Endpoint data
 390:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] iMaxLen Maximum number of bytes to read
 391:../common/lpcusb/target/usbhw_lpc.c ****             
 392:../common/lpcusb/target/usbhw_lpc.c ****     @return the number of bytes available in the EP (possibly more than iMaxLen),
 393:../common/lpcusb/target/usbhw_lpc.c ****     or <0 in case of error.
 394:../common/lpcusb/target/usbhw_lpc.c ****  */
 395:../common/lpcusb/target/usbhw_lpc.c **** int USBHwEPRead(U8 bEP, U8 *pbBuf, U32 iMaxLen)
 396:../common/lpcusb/target/usbhw_lpc.c **** {
 550              		.loc 1 396 0
 551              		.cfi_startproc
 552              		@ args = 0, pretend = 0, frame = 0
 553              		@ frame_needed = 0, uses_anonymous_args = 0
 554              	.LVL50:
 555 0000 38B5     		push	{r3, r4, r5, lr}
 556              		.cfi_def_cfa_offset 16
 557              		.cfi_offset 3, -16
 558              		.cfi_offset 4, -12
 559              		.cfi_offset 5, -8
 560              		.cfi_offset 14, -4
 397:../common/lpcusb/target/usbhw_lpc.c ****     U32 i, idx;
 398:../common/lpcusb/target/usbhw_lpc.c ****     U32 dwData, dwLen;
 399:../common/lpcusb/target/usbhw_lpc.c ****     
 400:../common/lpcusb/target/usbhw_lpc.c ****     idx = EP2IDX(bEP);
 561              		.loc 1 400 0
 562 0002 00F00F03 		and	r3, r0, #15
 563 0006 C009     		lsrs	r0, r0, #7
 564              	.LVL51:
 565 0008 40EA4300 		orr	r0, r0, r3, lsl #1
 566              	.LVL52:
 401:../common/lpcusb/target/usbhw_lpc.c ****     
 402:../common/lpcusb/target/usbhw_lpc.c ****     // set read enable bit for specific endpoint
 403:../common/lpcusb/target/usbhw_lpc.c ****     USBCtrl = RD_EN | ((bEP & 0xF) << 2);
 567              		.loc 1 403 0
 568 000c 144C     		ldr	r4, .L51
 569 000e 9B00     		lsls	r3, r3, #2
 570 0010 43F00103 		orr	r3, r3, #1
 571 0014 2360     		str	r3, [r4]
 572              	.L40:
 404:../common/lpcusb/target/usbhw_lpc.c ****     
 405:../common/lpcusb/target/usbhw_lpc.c ****     // wait for PKT_RDY
 406:../common/lpcusb/target/usbhw_lpc.c ****     do {
 407:../common/lpcusb/target/usbhw_lpc.c ****         dwLen = USBRxPLen;
ARM GAS  /tmp/cc3mLhQ4.s 			page 18


 573              		.loc 1 407 0 discriminator 1
 574 0016 134B     		ldr	r3, .L51+4
 575 0018 1B68     		ldr	r3, [r3]
 576              	.LVL53:
 408:../common/lpcusb/target/usbhw_lpc.c ****     } while ((dwLen & PKT_RDY) == 0);
 577              		.loc 1 408 0 discriminator 1
 578 001a 1D05     		lsls	r5, r3, #20
 579 001c FBD5     		bpl	.L40
 409:../common/lpcusb/target/usbhw_lpc.c ****     
 410:../common/lpcusb/target/usbhw_lpc.c ****     // packet valid?
 411:../common/lpcusb/target/usbhw_lpc.c ****     if ((dwLen & DV) == 0) {
 580              		.loc 1 411 0
 581 001e 5C05     		lsls	r4, r3, #21
 582 0020 1BD5     		bpl	.L46
 412:../common/lpcusb/target/usbhw_lpc.c ****         return -1;
 413:../common/lpcusb/target/usbhw_lpc.c ****     }
 414:../common/lpcusb/target/usbhw_lpc.c ****     
 415:../common/lpcusb/target/usbhw_lpc.c ****     // get length
 416:../common/lpcusb/target/usbhw_lpc.c ****     dwLen &= PKT_LNGTH_MASK;
 583              		.loc 1 416 0
 584 0022 C3F30905 		ubfx	r5, r3, #0, #10
 585              	.LVL54:
 417:../common/lpcusb/target/usbhw_lpc.c ****     
 418:../common/lpcusb/target/usbhw_lpc.c ****     // get data
 419:../common/lpcusb/target/usbhw_lpc.c ****     dwData = 0;
 586              		.loc 1 419 0
 587 0026 0023     		movs	r3, #0
 420:../common/lpcusb/target/usbhw_lpc.c ****     for (i = 0; i < dwLen; i++) {
 588              		.loc 1 420 0
 589 0028 1C46     		mov	r4, r3
 590              	.LVL55:
 591              	.L42:
 592              		.loc 1 420 0 is_stmt 0 discriminator 1
 593 002a AC42     		cmp	r4, r5
 594 002c 0BD0     		beq	.L50
 421:../common/lpcusb/target/usbhw_lpc.c ****         if ((i % 4) == 0) {
 595              		.loc 1 421 0 is_stmt 1
 596 002e 14F0030F 		tst	r4, #3
 422:../common/lpcusb/target/usbhw_lpc.c ****             dwData = USBRxData;
 597              		.loc 1 422 0
 598 0032 04BF     		itt	eq
 599 0034 0C4B     		ldreq	r3, .L51+8
 600              	.LVL56:
 601 0036 1B68     		ldreq	r3, [r3]
 602              	.LVL57:
 423:../common/lpcusb/target/usbhw_lpc.c ****         }
 424:../common/lpcusb/target/usbhw_lpc.c ****         if ((pbBuf != NULL) && (i < iMaxLen)) {
 603              		.loc 1 424 0
 604 0038 11B1     		cbz	r1, .L44
 605              		.loc 1 424 0 is_stmt 0 discriminator 1
 606 003a 9442     		cmp	r4, r2
 425:../common/lpcusb/target/usbhw_lpc.c ****             pbBuf[i] = dwData & 0xFF;
 607              		.loc 1 425 0 is_stmt 1 discriminator 1
 608 003c 38BF     		it	cc
 609 003e 0B55     		strbcc	r3, [r1, r4]
 610              	.L44:
 426:../common/lpcusb/target/usbhw_lpc.c ****         }
ARM GAS  /tmp/cc3mLhQ4.s 			page 19


 427:../common/lpcusb/target/usbhw_lpc.c ****         dwData >>= 8;
 611              		.loc 1 427 0
 612 0040 1B0A     		lsrs	r3, r3, #8
 613              	.LVL58:
 420:../common/lpcusb/target/usbhw_lpc.c ****         if ((i % 4) == 0) {
 614              		.loc 1 420 0
 615 0042 0134     		adds	r4, r4, #1
 616              	.LVL59:
 617 0044 F1E7     		b	.L42
 618              	.L50:
 428:../common/lpcusb/target/usbhw_lpc.c ****     }
 429:../common/lpcusb/target/usbhw_lpc.c **** 
 430:../common/lpcusb/target/usbhw_lpc.c ****     // make sure RD_EN is clear
 431:../common/lpcusb/target/usbhw_lpc.c ****     USBCtrl = 0;
 619              		.loc 1 431 0
 620 0046 064B     		ldr	r3, .L51
 621              	.LVL60:
 622 0048 0022     		movs	r2, #0
 623              	.LVL61:
 624 004a 1A60     		str	r2, [r3]
 432:../common/lpcusb/target/usbhw_lpc.c **** 
 433:../common/lpcusb/target/usbhw_lpc.c ****     // select endpoint and clear buffer
 434:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(CMD_EP_SELECT | idx);
 625              		.loc 1 434 0
 626 004c FFF7FEFF 		bl	USBHwCmd
 627              	.LVL62:
 435:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(CMD_EP_CLEAR_BUFFER);
 628              		.loc 1 435 0
 629 0050 F220     		movs	r0, #242
 630 0052 FFF7FEFF 		bl	USBHwCmd
 631              	.LVL63:
 436:../common/lpcusb/target/usbhw_lpc.c ****     
 437:../common/lpcusb/target/usbhw_lpc.c ****     return dwLen;
 632              		.loc 1 437 0
 633 0056 2046     		mov	r0, r4
 634 0058 38BD     		pop	{r3, r4, r5, pc}
 635              	.LVL64:
 636              	.L46:
 412:../common/lpcusb/target/usbhw_lpc.c ****     }
 637              		.loc 1 412 0
 638 005a 4FF0FF30 		mov	r0, #-1
 639              	.LVL65:
 438:../common/lpcusb/target/usbhw_lpc.c **** }
 640              		.loc 1 438 0
 641 005e 38BD     		pop	{r3, r4, r5, pc}
 642              	.LVL66:
 643              	.L52:
 644              		.align	2
 645              	.L51:
 646 0060 28C20050 		.word	1342226984
 647 0064 20C20050 		.word	1342226976
 648 0068 18C20050 		.word	1342226968
 649              		.cfi_endproc
 650              	.LFE16:
 652              		.section	.text.USBHwISOCEPRead,"ax",%progbits
 653              		.align	1
 654              		.global	USBHwISOCEPRead
ARM GAS  /tmp/cc3mLhQ4.s 			page 20


 655              		.thumb
 656              		.thumb_func
 658              	USBHwISOCEPRead:
 659              	.LFB18:
 439:../common/lpcusb/target/usbhw_lpc.c **** 
 440:../common/lpcusb/target/usbhw_lpc.c **** static void fast_wait() {
 441:../common/lpcusb/target/usbhw_lpc.c **** #ifdef __GNUC__
 442:../common/lpcusb/target/usbhw_lpc.c ****     asm volatile("nop\n"); 
 443:../common/lpcusb/target/usbhw_lpc.c **** #endif
 444:../common/lpcusb/target/usbhw_lpc.c **** 
 445:../common/lpcusb/target/usbhw_lpc.c **** #ifdef __arm__
 446:../common/lpcusb/target/usbhw_lpc.c ****     volatile uint32_t fast_wait = 1;
 447:../common/lpcusb/target/usbhw_lpc.c ****     while(--fast_wait);
 448:../common/lpcusb/target/usbhw_lpc.c **** #endif
 449:../common/lpcusb/target/usbhw_lpc.c **** }
 450:../common/lpcusb/target/usbhw_lpc.c **** 
 451:../common/lpcusb/target/usbhw_lpc.c **** 
 452:../common/lpcusb/target/usbhw_lpc.c **** int USBHwISOCEPRead(const U8 bEP, U8 *pbBuf, const U32 iMaxLen)
 453:../common/lpcusb/target/usbhw_lpc.c **** {
 660              		.loc 1 453 0
 661              		.cfi_startproc
 662              		@ args = 0, pretend = 0, frame = 8
 663              		@ frame_needed = 0, uses_anonymous_args = 0
 664              	.LVL67:
 665 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 666              		.cfi_def_cfa_offset 24
 667              		.cfi_offset 0, -24
 668              		.cfi_offset 1, -20
 669              		.cfi_offset 2, -16
 670              		.cfi_offset 4, -12
 671              		.cfi_offset 5, -8
 672              		.cfi_offset 14, -4
 454:../common/lpcusb/target/usbhw_lpc.c ****     U32 i, idx;
 455:../common/lpcusb/target/usbhw_lpc.c ****     U32 dwData, dwLen;
 456:../common/lpcusb/target/usbhw_lpc.c **** 
 457:../common/lpcusb/target/usbhw_lpc.c ****     idx = EP2IDX(bEP);
 673              		.loc 1 457 0
 674 0002 00F00F03 		and	r3, r0, #15
 675 0006 C009     		lsrs	r0, r0, #7
 676              	.LVL68:
 677 0008 40EA4300 		orr	r0, r0, r3, lsl #1
 678              	.LVL69:
 458:../common/lpcusb/target/usbhw_lpc.c **** 
 459:../common/lpcusb/target/usbhw_lpc.c ****     // set read enable bit for specific endpoint
 460:../common/lpcusb/target/usbhw_lpc.c ****     USBCtrl = RD_EN | ((bEP & 0xF) << 2);
 679              		.loc 1 460 0
 680 000c 1A4C     		ldr	r4, .L68
 681 000e 9B00     		lsls	r3, r3, #2
 682 0010 43F00103 		orr	r3, r3, #1
 683 0014 2360     		str	r3, [r4]
 684              	.LBB18:
 685              	.LBB19:
 442:../common/lpcusb/target/usbhw_lpc.c **** #endif
 686              		.loc 1 442 0
 687              	@ 442 "../common/lpcusb/target/usbhw_lpc.c" 1
 688 0016 00BF     		nop
 689              	
ARM GAS  /tmp/cc3mLhQ4.s 			page 21


 690              	@ 0 "" 2
 446:../common/lpcusb/target/usbhw_lpc.c ****     while(--fast_wait);
 691              		.loc 1 446 0
 692              		.thumb
 693 0018 0123     		movs	r3, #1
 694 001a 0193     		str	r3, [sp, #4]
 695              	.L55:
 447:../common/lpcusb/target/usbhw_lpc.c **** #endif
 696              		.loc 1 447 0
 697 001c 019D     		ldr	r5, [sp, #4]
 698 001e 013D     		subs	r5, r5, #1
 699 0020 0195     		str	r5, [sp, #4]
 700 0022 002D     		cmp	r5, #0
 701 0024 FAD1     		bne	.L55
 702              	.LBE19:
 703              	.LBE18:
 461:../common/lpcusb/target/usbhw_lpc.c ****     
 462:../common/lpcusb/target/usbhw_lpc.c ****     //Note: for some reason the USB perepherial needs a cycle to set bits in USBRxPLen before 
 463:../common/lpcusb/target/usbhw_lpc.c ****     //reading, if you remove this ISOC wont work. This may be a but in the chip, or due to 
 464:../common/lpcusb/target/usbhw_lpc.c ****     //a mis-understanding of how the perepherial is supposed to work.    
 465:../common/lpcusb/target/usbhw_lpc.c ****     fast_wait();
 466:../common/lpcusb/target/usbhw_lpc.c ****     
 467:../common/lpcusb/target/usbhw_lpc.c ****     dwLen = USBRxPLen;
 704              		.loc 1 467 0
 705 0026 154B     		ldr	r3, .L68+4
 706 0028 1B68     		ldr	r3, [r3]
 707              	.LVL70:
 468:../common/lpcusb/target/usbhw_lpc.c ****     if( (dwLen & PKT_RDY) == 0 ) {
 708              		.loc 1 468 0
 709 002a 13F40064 		ands	r4, r3, #2048
 710 002e 02D0     		beq	.L66
 469:../common/lpcusb/target/usbhw_lpc.c ****         USBCtrl = 0;// make sure RD_EN is clear
 470:../common/lpcusb/target/usbhw_lpc.c ****         return(-1);
 471:../common/lpcusb/target/usbhw_lpc.c ****     }
 472:../common/lpcusb/target/usbhw_lpc.c **** 
 473:../common/lpcusb/target/usbhw_lpc.c ****     // packet valid?
 474:../common/lpcusb/target/usbhw_lpc.c ****     if ((dwLen & DV) == 0) {
 711              		.loc 1 474 0
 712 0030 13F48064 		ands	r4, r3, #1024
 713 0034 04D1     		bne	.L58
 714              	.L66:
 475:../common/lpcusb/target/usbhw_lpc.c ****         USBCtrl = 0;// make sure RD_EN is clear
 715              		.loc 1 475 0
 716 0036 104B     		ldr	r3, .L68
 717              	.LVL71:
 476:../common/lpcusb/target/usbhw_lpc.c ****         return -1;
 718              		.loc 1 476 0
 719 0038 4FF0FF30 		mov	r0, #-1
 720              	.LVL72:
 475:../common/lpcusb/target/usbhw_lpc.c ****         USBCtrl = 0;// make sure RD_EN is clear
 721              		.loc 1 475 0
 722 003c 1C60     		str	r4, [r3]
 723              		.loc 1 476 0
 724 003e 19E0     		b	.L57
 725              	.LVL73:
 726              	.L58:
 477:../common/lpcusb/target/usbhw_lpc.c ****     }
ARM GAS  /tmp/cc3mLhQ4.s 			page 22


 478:../common/lpcusb/target/usbhw_lpc.c **** 
 479:../common/lpcusb/target/usbhw_lpc.c ****     // get length
 480:../common/lpcusb/target/usbhw_lpc.c ****     dwLen &= PKT_LNGTH_MASK;
 727              		.loc 1 480 0
 728 0040 C3F30903 		ubfx	r3, r3, #0, #10
 729              	.LVL74:
 481:../common/lpcusb/target/usbhw_lpc.c **** 
 482:../common/lpcusb/target/usbhw_lpc.c ****     // get data
 483:../common/lpcusb/target/usbhw_lpc.c ****     dwData = 0;
 484:../common/lpcusb/target/usbhw_lpc.c ****     for (i = 0; i < dwLen; i++) {
 730              		.loc 1 484 0
 731 0044 2C46     		mov	r4, r5
 732              	.LVL75:
 733              	.L59:
 734              		.loc 1 484 0 is_stmt 0 discriminator 1
 735 0046 9C42     		cmp	r4, r3
 736 0048 0BD0     		beq	.L67
 485:../common/lpcusb/target/usbhw_lpc.c ****         if ((i % 4) == 0) {
 737              		.loc 1 485 0 is_stmt 1
 738 004a 14F0030F 		tst	r4, #3
 486:../common/lpcusb/target/usbhw_lpc.c ****             dwData = USBRxData;
 739              		.loc 1 486 0
 740 004e 04BF     		itt	eq
 741 0050 0B4D     		ldreq	r5, .L68+8
 742              	.LVL76:
 743 0052 2D68     		ldreq	r5, [r5]
 744              	.LVL77:
 487:../common/lpcusb/target/usbhw_lpc.c ****         }
 488:../common/lpcusb/target/usbhw_lpc.c ****         if ((pbBuf != NULL) && (i < iMaxLen)) {
 745              		.loc 1 488 0
 746 0054 11B1     		cbz	r1, .L61
 747              		.loc 1 488 0 is_stmt 0 discriminator 1
 748 0056 9442     		cmp	r4, r2
 489:../common/lpcusb/target/usbhw_lpc.c ****             pbBuf[i] = dwData & 0xFF;
 749              		.loc 1 489 0 is_stmt 1 discriminator 1
 750 0058 38BF     		it	cc
 751 005a 0D55     		strbcc	r5, [r1, r4]
 752              	.L61:
 490:../common/lpcusb/target/usbhw_lpc.c ****         }
 491:../common/lpcusb/target/usbhw_lpc.c ****         dwData >>= 8;
 753              		.loc 1 491 0
 754 005c 2D0A     		lsrs	r5, r5, #8
 755              	.LVL78:
 484:../common/lpcusb/target/usbhw_lpc.c ****         if ((i % 4) == 0) {
 756              		.loc 1 484 0
 757 005e 0134     		adds	r4, r4, #1
 758              	.LVL79:
 759 0060 F1E7     		b	.L59
 760              	.L67:
 492:../common/lpcusb/target/usbhw_lpc.c ****     }
 493:../common/lpcusb/target/usbhw_lpc.c **** 
 494:../common/lpcusb/target/usbhw_lpc.c ****     // make sure RD_EN is clear
 495:../common/lpcusb/target/usbhw_lpc.c ****     USBCtrl = 0;
 761              		.loc 1 495 0
 762 0062 054B     		ldr	r3, .L68
 763              	.LVL80:
 764 0064 0022     		movs	r2, #0
ARM GAS  /tmp/cc3mLhQ4.s 			page 23


 765              	.LVL81:
 766 0066 1A60     		str	r2, [r3]
 496:../common/lpcusb/target/usbhw_lpc.c **** 
 497:../common/lpcusb/target/usbhw_lpc.c ****     // select endpoint and clear buffer
 498:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(CMD_EP_SELECT | idx);
 767              		.loc 1 498 0
 768 0068 FFF7FEFF 		bl	USBHwCmd
 769              	.LVL82:
 499:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmd(CMD_EP_CLEAR_BUFFER);
 770              		.loc 1 499 0
 771 006c F220     		movs	r0, #242
 772 006e FFF7FEFF 		bl	USBHwCmd
 773              	.LVL83:
 500:../common/lpcusb/target/usbhw_lpc.c **** 
 501:../common/lpcusb/target/usbhw_lpc.c ****     return dwLen;
 774              		.loc 1 501 0
 775 0072 2046     		mov	r0, r4
 776              	.LVL84:
 777              	.L57:
 502:../common/lpcusb/target/usbhw_lpc.c **** }
 778              		.loc 1 502 0
 779 0074 03B0     		add	sp, sp, #12
 780              		@ sp needed
 781 0076 30BD     		pop	{r4, r5, pc}
 782              	.L69:
 783              		.align	2
 784              	.L68:
 785 0078 28C20050 		.word	1342226984
 786 007c 20C20050 		.word	1342226976
 787 0080 18C20050 		.word	1342226968
 788              		.cfi_endproc
 789              	.LFE18:
 791              		.section	.text.USBHwConfigDevice,"ax",%progbits
 792              		.align	1
 793              		.global	USBHwConfigDevice
 794              		.thumb
 795              		.thumb_func
 797              	USBHwConfigDevice:
 798              	.LFB19:
 503:../common/lpcusb/target/usbhw_lpc.c **** 
 504:../common/lpcusb/target/usbhw_lpc.c **** 
 505:../common/lpcusb/target/usbhw_lpc.c **** /**
 506:../common/lpcusb/target/usbhw_lpc.c ****     Sets the 'configured' state.
 507:../common/lpcusb/target/usbhw_lpc.c ****         
 508:../common/lpcusb/target/usbhw_lpc.c ****     All registered endpoints are 'realised' and enabled, and the
 509:../common/lpcusb/target/usbhw_lpc.c ****     'configured' bit is set in the device status register.
 510:../common/lpcusb/target/usbhw_lpc.c ****         
 511:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] fConfigured If TRUE, configure device, else unconfigure
 512:../common/lpcusb/target/usbhw_lpc.c ****  */
 513:../common/lpcusb/target/usbhw_lpc.c **** void USBHwConfigDevice(BOOL fConfigured)
 514:../common/lpcusb/target/usbhw_lpc.c **** {
 799              		.loc 1 514 0
 800              		.cfi_startproc
 801              		@ args = 0, pretend = 0, frame = 0
 802              		@ frame_needed = 0, uses_anonymous_args = 0
 803              		@ link register save eliminated.
 804              	.LVL85:
ARM GAS  /tmp/cc3mLhQ4.s 			page 24


 515:../common/lpcusb/target/usbhw_lpc.c ****     // set configured bit
 516:../common/lpcusb/target/usbhw_lpc.c ****     USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
 805              		.loc 1 516 0
 806 0000 011C     		adds	r1, r0, #0
 807 0002 18BF     		it	ne
 808 0004 0121     		movne	r1, #1
 809 0006 D820     		movs	r0, #216
 810              	.LVL86:
 811 0008 FFF7FEBF 		b	USBHwCmdWrite
 812              	.LVL87:
 813              		.cfi_endproc
 814              	.LFE19:
 816              		.section	.text.USBHwISR,"ax",%progbits
 817              		.align	1
 818              		.global	USBHwISR
 819              		.thumb
 820              		.thumb_func
 822              	USBHwISR:
 823              	.LFB20:
 517:../common/lpcusb/target/usbhw_lpc.c **** }
 518:../common/lpcusb/target/usbhw_lpc.c **** 
 519:../common/lpcusb/target/usbhw_lpc.c **** 
 520:../common/lpcusb/target/usbhw_lpc.c **** /**
 521:../common/lpcusb/target/usbhw_lpc.c ****     USB interrupt handler
 522:../common/lpcusb/target/usbhw_lpc.c ****         
 523:../common/lpcusb/target/usbhw_lpc.c ****     @todo Get all 11 bits of frame number instead of just 8
 524:../common/lpcusb/target/usbhw_lpc.c **** 
 525:../common/lpcusb/target/usbhw_lpc.c ****     Endpoint interrupts are mapped to the slow interrupt
 526:../common/lpcusb/target/usbhw_lpc.c ****  */
 527:../common/lpcusb/target/usbhw_lpc.c **** void USBHwISR(void)
 528:../common/lpcusb/target/usbhw_lpc.c **** {
 824              		.loc 1 528 0
 825              		.cfi_startproc
 826              		@ args = 0, pretend = 0, frame = 0
 827              		@ frame_needed = 0, uses_anonymous_args = 0
 828 0000 38B5     		push	{r3, r4, r5, lr}
 829              		.cfi_def_cfa_offset 16
 830              		.cfi_offset 3, -16
 831              		.cfi_offset 4, -12
 832              		.cfi_offset 5, -8
 833              		.cfi_offset 14, -4
 529:../common/lpcusb/target/usbhw_lpc.c ****     U32 dwStatus;
 530:../common/lpcusb/target/usbhw_lpc.c ****     U32 dwIntBit;
 531:../common/lpcusb/target/usbhw_lpc.c ****     U8  bEPStat, bDevStat, bStat;
 532:../common/lpcusb/target/usbhw_lpc.c ****     int i;
 533:../common/lpcusb/target/usbhw_lpc.c ****     U16 wFrame;
 534:../common/lpcusb/target/usbhw_lpc.c **** 
 535:../common/lpcusb/target/usbhw_lpc.c **** // LED9 monitors total time in interrupt routine
 536:../common/lpcusb/target/usbhw_lpc.c **** DEBUG_LED_ON(9);
 537:../common/lpcusb/target/usbhw_lpc.c **** 
 538:../common/lpcusb/target/usbhw_lpc.c ****     // handle device interrupts
 539:../common/lpcusb/target/usbhw_lpc.c ****     dwStatus = USBDevIntSt;
 834              		.loc 1 539 0
 835 0002 294B     		ldr	r3, .L99
 836 0004 1C68     		ldr	r4, [r3]
 837              	.LVL88:
 540:../common/lpcusb/target/usbhw_lpc.c ****     
ARM GAS  /tmp/cc3mLhQ4.s 			page 25


 541:../common/lpcusb/target/usbhw_lpc.c ****     // frame interrupt
 542:../common/lpcusb/target/usbhw_lpc.c ****     if (dwStatus & FRAME) {
 838              		.loc 1 542 0
 839 0006 E107     		lsls	r1, r4, #31
 840 0008 11D5     		bpl	.L73
 543:../common/lpcusb/target/usbhw_lpc.c ****         // clear int
 544:../common/lpcusb/target/usbhw_lpc.c ****         USBDevIntClr = FRAME;
 841              		.loc 1 544 0
 842 000a 0122     		movs	r2, #1
 843 000c 9A60     		str	r2, [r3, #8]
 545:../common/lpcusb/target/usbhw_lpc.c ****         // call handler
 546:../common/lpcusb/target/usbhw_lpc.c ****         if (_pfnFrameHandler != NULL) {
 844              		.loc 1 546 0
 845 000e 274B     		ldr	r3, .L99+4
 846 0010 5D6C     		ldr	r5, [r3, #68]
 847 0012 65B1     		cbz	r5, .L73
 848              	.LVL89:
 849              	.LBB24:
 850              	.LBB25:
 144:../common/lpcusb/target/usbhw_lpc.c ****     
 851              		.loc 1 144 0
 852 0014 F520     		movs	r0, #245
 853 0016 FFF7FEFF 		bl	USBHwCmd
 854              	.LVL90:
 147:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CDFULL);
 855              		.loc 1 147 0
 856 001a 254B     		ldr	r3, .L99+8
 857 001c 254A     		ldr	r2, .L99+12
 148:../common/lpcusb/target/usbhw_lpc.c ****     return USBCmdData;
 858              		.loc 1 148 0
 859 001e 2020     		movs	r0, #32
 147:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CDFULL);
 860              		.loc 1 147 0
 861 0020 1A60     		str	r2, [r3]
 148:../common/lpcusb/target/usbhw_lpc.c ****     return USBCmdData;
 862              		.loc 1 148 0
 863 0022 FFF7FEFF 		bl	Wait4DevInt
 864              	.LVL91:
 149:../common/lpcusb/target/usbhw_lpc.c **** }
 865              		.loc 1 149 0
 866 0026 244B     		ldr	r3, .L99+16
 867 0028 1868     		ldr	r0, [r3]
 868              	.LVL92:
 869              	.LBE25:
 870              	.LBE24:
 547:../common/lpcusb/target/usbhw_lpc.c ****             wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
 548:../common/lpcusb/target/usbhw_lpc.c ****             _pfnFrameHandler(wFrame);
 871              		.loc 1 548 0
 872 002a C0B2     		uxtb	r0, r0
 873              	.LVL93:
 874 002c A847     		blx	r5
 875              	.LVL94:
 876              	.L73:
 549:../common/lpcusb/target/usbhw_lpc.c ****         }
 550:../common/lpcusb/target/usbhw_lpc.c ****     }
 551:../common/lpcusb/target/usbhw_lpc.c ****     
 552:../common/lpcusb/target/usbhw_lpc.c ****     // device status interrupt
ARM GAS  /tmp/cc3mLhQ4.s 			page 26


 553:../common/lpcusb/target/usbhw_lpc.c ****     if (dwStatus & DEV_STAT) {
 877              		.loc 1 553 0
 878 002e 2207     		lsls	r2, r4, #28
 879 0030 17D5     		bpl	.L76
 554:../common/lpcusb/target/usbhw_lpc.c ****         /*  Clear DEV_STAT interrupt before reading DEV_STAT register.
 555:../common/lpcusb/target/usbhw_lpc.c ****             This prevents corrupted device status reads, see
 556:../common/lpcusb/target/usbhw_lpc.c ****             LPC2148 User manual revision 2, 25 july 2006.
 557:../common/lpcusb/target/usbhw_lpc.c ****         */
 558:../common/lpcusb/target/usbhw_lpc.c ****         USBDevIntClr = DEV_STAT;
 880              		.loc 1 558 0
 881 0032 224B     		ldr	r3, .L99+20
 882 0034 0822     		movs	r2, #8
 883 0036 1A60     		str	r2, [r3]
 884              	.LVL95:
 885              	.LBB26:
 886              	.LBB27:
 144:../common/lpcusb/target/usbhw_lpc.c ****     
 887              		.loc 1 144 0
 888 0038 FE20     		movs	r0, #254
 889 003a FFF7FEFF 		bl	USBHwCmd
 890              	.LVL96:
 147:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CDFULL);
 891              		.loc 1 147 0
 892 003e 1C4B     		ldr	r3, .L99+8
 893 0040 1F4A     		ldr	r2, .L99+24
 148:../common/lpcusb/target/usbhw_lpc.c ****     return USBCmdData;
 894              		.loc 1 148 0
 895 0042 2020     		movs	r0, #32
 147:../common/lpcusb/target/usbhw_lpc.c ****     Wait4DevInt(CDFULL);
 896              		.loc 1 147 0
 897 0044 1A60     		str	r2, [r3]
 148:../common/lpcusb/target/usbhw_lpc.c ****     return USBCmdData;
 898              		.loc 1 148 0
 899 0046 FFF7FEFF 		bl	Wait4DevInt
 900              	.LVL97:
 149:../common/lpcusb/target/usbhw_lpc.c **** }
 901              		.loc 1 149 0
 902 004a 1B4B     		ldr	r3, .L99+16
 903 004c 1868     		ldr	r0, [r3]
 904 004e C0B2     		uxtb	r0, r0
 905              	.LBE27:
 906              	.LBE26:
 559:../common/lpcusb/target/usbhw_lpc.c ****         bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
 560:../common/lpcusb/target/usbhw_lpc.c ****         if (bDevStat & (CON_CH | SUS_CH | RST)) {
 907              		.loc 1 560 0
 908 0050 10F01A0F 		tst	r0, #26
 909 0054 05D0     		beq	.L76
 910              	.LVL98:
 561:../common/lpcusb/target/usbhw_lpc.c ****             // convert device status into something HW independent
 562:../common/lpcusb/target/usbhw_lpc.c ****             bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
 563:../common/lpcusb/target/usbhw_lpc.c ****                     ((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
 564:../common/lpcusb/target/usbhw_lpc.c ****                     ((bDevStat & RST) ? DEV_STATUS_RESET : 0);
 565:../common/lpcusb/target/usbhw_lpc.c ****             // call handler
 566:../common/lpcusb/target/usbhw_lpc.c ****             if (_pfnDevIntHandler != NULL) {
 911              		.loc 1 566 0
 912 0056 154B     		ldr	r3, .L99+4
 913 0058 1B6C     		ldr	r3, [r3, #64]
ARM GAS  /tmp/cc3mLhQ4.s 			page 27


 914 005a 13B1     		cbz	r3, .L76
 567:../common/lpcusb/target/usbhw_lpc.c **** DEBUG_LED_ON(8);        
 568:../common/lpcusb/target/usbhw_lpc.c ****                 _pfnDevIntHandler(bStat);
 915              		.loc 1 568 0
 916 005c 00F01500 		and	r0, r0, #21
 917 0060 9847     		blx	r3
 918              	.LVL99:
 919              	.L76:
 569:../common/lpcusb/target/usbhw_lpc.c **** DEBUG_LED_OFF(8);       
 570:../common/lpcusb/target/usbhw_lpc.c ****             }
 571:../common/lpcusb/target/usbhw_lpc.c ****         }
 572:../common/lpcusb/target/usbhw_lpc.c ****     }
 573:../common/lpcusb/target/usbhw_lpc.c ****     
 574:../common/lpcusb/target/usbhw_lpc.c ****     // endpoint interrupt
 575:../common/lpcusb/target/usbhw_lpc.c ****     if (dwStatus & EP_SLOW) {
 920              		.loc 1 575 0
 921 0062 6307     		lsls	r3, r4, #29
 922 0064 1ED5     		bpl	.L71
 576:../common/lpcusb/target/usbhw_lpc.c ****         // clear EP_SLOW
 577:../common/lpcusb/target/usbhw_lpc.c ****         USBDevIntClr = EP_SLOW;
 923              		.loc 1 577 0
 924 0066 154B     		ldr	r3, .L99+20
 925 0068 0422     		movs	r2, #4
 926 006a 1A60     		str	r2, [r3]
 927              	.LVL100:
 578:../common/lpcusb/target/usbhw_lpc.c ****         // check all endpoints
 579:../common/lpcusb/target/usbhw_lpc.c ****         for (i = 0; i < 32; i++) {
 928              		.loc 1 579 0
 929 006c 0024     		movs	r4, #0
 930              	.LVL101:
 931              	.L83:
 580:../common/lpcusb/target/usbhw_lpc.c ****             dwIntBit = (1 << i);
 932              		.loc 1 580 0
 933 006e 0123     		movs	r3, #1
 934 0070 A340     		lsls	r3, r3, r4
 935              	.LVL102:
 581:../common/lpcusb/target/usbhw_lpc.c ****             if (USBEpIntSt & dwIntBit) {
 936              		.loc 1 581 0
 937 0072 144A     		ldr	r2, .L99+28
 938 0074 1268     		ldr	r2, [r2]
 939 0076 1342     		tst	r3, r2
 940 0078 11D0     		beq	.L80
 582:../common/lpcusb/target/usbhw_lpc.c ****                 // clear int (and retrieve status)
 583:../common/lpcusb/target/usbhw_lpc.c ****                 USBEpIntClr = dwIntBit;
 941              		.loc 1 583 0
 942 007a 134A     		ldr	r2, .L99+32
 584:../common/lpcusb/target/usbhw_lpc.c ****                 Wait4DevInt(CDFULL);
 943              		.loc 1 584 0
 944 007c 2020     		movs	r0, #32
 583:../common/lpcusb/target/usbhw_lpc.c ****                 Wait4DevInt(CDFULL);
 945              		.loc 1 583 0
 946 007e 1360     		str	r3, [r2]
 947              		.loc 1 584 0
 948 0080 FFF7FEFF 		bl	Wait4DevInt
 949              	.LVL103:
 585:../common/lpcusb/target/usbhw_lpc.c ****                 bEPStat = USBCmdData;
 950              		.loc 1 585 0
ARM GAS  /tmp/cc3mLhQ4.s 			page 28


 951 0084 0C4B     		ldr	r3, .L99+16
 586:../common/lpcusb/target/usbhw_lpc.c ****                 // convert EP pipe stat into something HW independent
 587:../common/lpcusb/target/usbhw_lpc.c ****                 bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
 588:../common/lpcusb/target/usbhw_lpc.c ****                         ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
 589:../common/lpcusb/target/usbhw_lpc.c ****                         ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
 590:../common/lpcusb/target/usbhw_lpc.c ****                         ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
 591:../common/lpcusb/target/usbhw_lpc.c ****                         ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
 592:../common/lpcusb/target/usbhw_lpc.c ****                 // call handler
 593:../common/lpcusb/target/usbhw_lpc.c ****                 if (_apfnEPIntHandlers[i / 2] != NULL) {
 952              		.loc 1 593 0
 953 0086 6010     		asrs	r0, r4, #1
 585:../common/lpcusb/target/usbhw_lpc.c ****                 bEPStat = USBCmdData;
 954              		.loc 1 585 0
 955 0088 1968     		ldr	r1, [r3]
 956              	.LVL104:
 957              		.loc 1 593 0
 958 008a 084B     		ldr	r3, .L99+4
 959 008c 53F82030 		ldr	r3, [r3, r0, lsl #2]
 960 0090 2BB1     		cbz	r3, .L80
 594:../common/lpcusb/target/usbhw_lpc.c **** DEBUG_LED_ON(10);       
 595:../common/lpcusb/target/usbhw_lpc.c ****                     _apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
 961              		.loc 1 595 0
 962 0092 40EAC410 		orr	r0, r0, r4, lsl #7
 963 0096 C0B2     		uxtb	r0, r0
 964 0098 01F01F01 		and	r1, r1, #31
 965              	.LVL105:
 966 009c 9847     		blx	r3
 967              	.LVL106:
 968              	.L80:
 579:../common/lpcusb/target/usbhw_lpc.c ****             dwIntBit = (1 << i);
 969              		.loc 1 579 0
 970 009e 0134     		adds	r4, r4, #1
 971              	.LVL107:
 972 00a0 202C     		cmp	r4, #32
 973 00a2 E4D1     		bne	.L83
 974              	.LVL108:
 975              	.L71:
 976 00a4 38BD     		pop	{r3, r4, r5, pc}
 977              	.L100:
 978 00a6 00BF     		.align	2
 979              	.L99:
 980 00a8 00C20050 		.word	1342226944
 981 00ac 00000000 		.word	.LANCHOR0
 982 00b0 10C20050 		.word	1342226960
 983 00b4 0002F500 		.word	16056832
 984 00b8 14C20050 		.word	1342226964
 985 00bc 08C20050 		.word	1342226952
 986 00c0 0002FE00 		.word	16646656
 987 00c4 30C20050 		.word	1342226992
 988 00c8 38C20050 		.word	1342227000
 989              		.cfi_endproc
 990              	.LFE20:
 992              		.section	.text.USBHwInit,"ax",%progbits
 993              		.align	1
 994              		.global	USBHwInit
 995              		.thumb
 996              		.thumb_func
ARM GAS  /tmp/cc3mLhQ4.s 			page 29


 998              	USBHwInit:
 999              	.LFB21:
 596:../common/lpcusb/target/usbhw_lpc.c **** DEBUG_LED_OFF(10);
 597:../common/lpcusb/target/usbhw_lpc.c ****                 }
 598:../common/lpcusb/target/usbhw_lpc.c ****             }
 599:../common/lpcusb/target/usbhw_lpc.c ****         }
 600:../common/lpcusb/target/usbhw_lpc.c ****     }
 601:../common/lpcusb/target/usbhw_lpc.c ****     
 602:../common/lpcusb/target/usbhw_lpc.c **** DEBUG_LED_OFF(9);       
 603:../common/lpcusb/target/usbhw_lpc.c **** }
 604:../common/lpcusb/target/usbhw_lpc.c **** 
 605:../common/lpcusb/target/usbhw_lpc.c **** 
 606:../common/lpcusb/target/usbhw_lpc.c **** 
 607:../common/lpcusb/target/usbhw_lpc.c **** /**
 608:../common/lpcusb/target/usbhw_lpc.c ****     Initialises the USB hardware
 609:../common/lpcusb/target/usbhw_lpc.c ****         
 610:../common/lpcusb/target/usbhw_lpc.c ****     This function assumes that the hardware is connected as shown in
 611:../common/lpcusb/target/usbhw_lpc.c ****     section 10.1 of the LPC2148 data sheet:
 612:../common/lpcusb/target/usbhw_lpc.c ****     * P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
 613:../common/lpcusb/target/usbhw_lpc.c ****     * P0.23 is connected to USB VCC.
 614:../common/lpcusb/target/usbhw_lpc.c ****     
 615:../common/lpcusb/target/usbhw_lpc.c ****     Embedded artists board: make sure to disconnect P0.23 LED as it
 616:../common/lpcusb/target/usbhw_lpc.c ****     acts as a pull-up and so prevents detection of USB disconnect.
 617:../common/lpcusb/target/usbhw_lpc.c ****         
 618:../common/lpcusb/target/usbhw_lpc.c ****     @return TRUE if the hardware was successfully initialised
 619:../common/lpcusb/target/usbhw_lpc.c ****  */
 620:../common/lpcusb/target/usbhw_lpc.c **** BOOL USBHwInit(void)
 621:../common/lpcusb/target/usbhw_lpc.c **** {
 1000              		.loc 1 621 0
 1001              		.cfi_startproc
 1002              		@ args = 0, pretend = 0, frame = 0
 1003              		@ frame_needed = 0, uses_anonymous_args = 0
 1004 0000 08B5     		push	{r3, lr}
 1005              		.cfi_def_cfa_offset 8
 1006              		.cfi_offset 3, -8
 1007              		.cfi_offset 14, -4
 622:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC17xx
 623:../common/lpcusb/target/usbhw_lpc.c **** 	// P2.9 is USB_CONNECT
 624:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18);
 1008              		.loc 1 624 0
 1009 0002 244B     		ldr	r3, .L106
 1010 0004 1A68     		ldr	r2, [r3]
 1011 0006 22F44022 		bic	r2, r2, #786432
 1012 000a 42F48022 		orr	r2, r2, #262144
 1013 000e 1A60     		str	r2, [r3]
 625:../common/lpcusb/target/usbhw_lpc.c **** 
 626:../common/lpcusb/target/usbhw_lpc.c **** 	// P1.18 is USB_UP_LED
 627:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL3 = (PINSEL3 & ~(3 << 4)) | (1 << 4);
 1014              		.loc 1 627 0
 1015 0010 53F8042C 		ldr	r2, [r3, #-4]
 1016 0014 22F03002 		bic	r2, r2, #48
 1017 0018 42F01002 		orr	r2, r2, #16
 1018 001c 43F8042C 		str	r2, [r3, #-4]
 628:../common/lpcusb/target/usbhw_lpc.c **** 
 629:../common/lpcusb/target/usbhw_lpc.c **** 	// P1.30 is VBUS
 630:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);
 1019              		.loc 1 630 0
ARM GAS  /tmp/cc3mLhQ4.s 			page 30


 1020 0020 53F8042C 		ldr	r2, [r3, #-4]
 1021 0024 22F04052 		bic	r2, r2, #805306368
 1022 0028 42F00052 		orr	r2, r2, #536870912
 1023 002c 43F8042C 		str	r2, [r3, #-4]
 631:../common/lpcusb/target/usbhw_lpc.c **** 
 632:../common/lpcusb/target/usbhw_lpc.c **** 	// P0.29 is USB_D+
 633:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL1 = (PINSEL1 & ~(3 << 26)) | (1 << 26);
 1024              		.loc 1 633 0
 1025 0030 53F80C2C 		ldr	r2, [r3, #-12]
 1026 0034 22F04062 		bic	r2, r2, #201326592
 1027 0038 42F08062 		orr	r2, r2, #67108864
 1028 003c 43F80C2C 		str	r2, [r3, #-12]
 634:../common/lpcusb/target/usbhw_lpc.c **** 
 635:../common/lpcusb/target/usbhw_lpc.c **** 	// P0.30 is USB_D-
 636:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL1 = (PINSEL1 & ~(3 << 28)) | (1 << 28);
 1029              		.loc 1 636 0
 1030 0040 53F80C2C 		ldr	r2, [r3, #-12]
 1031 0044 22F04052 		bic	r2, r2, #805306368
 1032 0048 42F08052 		orr	r2, r2, #268435456
 1033 004c 43F80C2C 		str	r2, [r3, #-12]
 637:../common/lpcusb/target/usbhw_lpc.c **** 
 638:../common/lpcusb/target/usbhw_lpc.c **** 	// enable PUSB
 639:../common/lpcusb/target/usbhw_lpc.c **** 	PCONP |= PCONP_PCUSB;
 1034              		.loc 1 639 0
 1035 0050 114B     		ldr	r3, .L106+4
 1036 0052 1A68     		ldr	r2, [r3]
 1037 0054 42F00042 		orr	r2, r2, #-2147483648
 1038 0058 1A60     		str	r2, [r3]
 640:../common/lpcusb/target/usbhw_lpc.c **** 
 641:../common/lpcusb/target/usbhw_lpc.c **** 	/* enable the USB controller clocks */
 642:../common/lpcusb/target/usbhw_lpc.c ****     USBClkCtrl |= (USBClkCtrl_DEV_CLK_EN | USBClkCtrl_AHB_CLK_EN);
 1039              		.loc 1 642 0
 1040 005a 104B     		ldr	r3, .L106+8
 1041 005c 1A68     		ldr	r2, [r3]
 1042 005e 42F01202 		orr	r2, r2, #18
 1043 0062 1A60     		str	r2, [r3]
 1044              	.L103:
 643:../common/lpcusb/target/usbhw_lpc.c ****     while (!(USBClkSt & USBClkSt_DEV_CLK_ON));
 1045              		.loc 1 643 0 discriminator 1
 1046 0064 0E4B     		ldr	r3, .L106+12
 1047 0066 1A68     		ldr	r2, [r3]
 1048 0068 9207     		lsls	r2, r2, #30
 1049 006a FBD5     		bpl	.L103
 1050              	.L105:
 644:../common/lpcusb/target/usbhw_lpc.c ****     while (!(USBClkSt & USBClkSt_AHB_CLK_ON));
 1051              		.loc 1 644 0
 1052 006c 1A68     		ldr	r2, [r3]
 1053 006e D006     		lsls	r0, r2, #27
 1054 0070 FCD5     		bpl	.L105
 645:../common/lpcusb/target/usbhw_lpc.c **** #endif
 646:../common/lpcusb/target/usbhw_lpc.c **** 
 647:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC214x
 648:../common/lpcusb/target/usbhw_lpc.c ****     
 649:../common/lpcusb/target/usbhw_lpc.c ****     // configure P0.23 for Vbus sense
 650:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);   // P0.23
 651:../common/lpcusb/target/usbhw_lpc.c ****     // configure P0.31 for CONNECT
 652:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);   // P0.31
ARM GAS  /tmp/cc3mLhQ4.s 			page 31


 653:../common/lpcusb/target/usbhw_lpc.c **** 
 654:../common/lpcusb/target/usbhw_lpc.c ****     // enable PUSB
 655:../common/lpcusb/target/usbhw_lpc.c ****     PCONP |= (1 << 31);     
 656:../common/lpcusb/target/usbhw_lpc.c **** 
 657:../common/lpcusb/target/usbhw_lpc.c ****     // initialise PLL
 658:../common/lpcusb/target/usbhw_lpc.c ****     PLL1CON = 1;            // enable PLL
 659:../common/lpcusb/target/usbhw_lpc.c ****     PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
 660:../common/lpcusb/target/usbhw_lpc.c ****     PLL1FEED = 0xAA;
 661:../common/lpcusb/target/usbhw_lpc.c ****     PLL1FEED = 0x55;
 662:../common/lpcusb/target/usbhw_lpc.c ****     while ((PLL1STAT & (1 << 10)) == 0);
 663:../common/lpcusb/target/usbhw_lpc.c **** 
 664:../common/lpcusb/target/usbhw_lpc.c ****     PLL1CON = 3;            // enable and connect
 665:../common/lpcusb/target/usbhw_lpc.c ****     PLL1FEED = 0xAA;
 666:../common/lpcusb/target/usbhw_lpc.c ****     PLL1FEED = 0x55;
 667:../common/lpcusb/target/usbhw_lpc.c **** 
 668:../common/lpcusb/target/usbhw_lpc.c **** #endif
 669:../common/lpcusb/target/usbhw_lpc.c **** 
 670:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC23xx
 671:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC2378_PORTB
 672:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL1 = (PINSEL1 & ~(3 << 30)) | (1 << 30);
 673:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);
 674:../common/lpcusb/target/usbhw_lpc.c ****     /* Due to a bug in the LPC23xx chips, the connection functionality must be
 675:../common/lpcusb/target/usbhw_lpc.c ****     * simulated using GPIO. Hopefully for production this will be fixed and the
 676:../common/lpcusb/target/usbhw_lpc.c ****     * commented out code will work */
 677:../common/lpcusb/target/usbhw_lpc.c ****     //PINSEL0 = (PINSEL0 & ~((3 << 26) | (3 << 28))) | (1 << 26) | (1 << 28); /* Doesn't work due t
 678:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL0 = (PINSEL0 & ~((3 << 26) | (3 << 28))) | (1 << 26);
 679:../common/lpcusb/target/usbhw_lpc.c ****     FIO0DIR |= (1<<14); /* Set pin to output */
 680:../common/lpcusb/target/usbhw_lpc.c ****     FIO0SET = (1<<14); /* Set output high to disconnect */
 681:../common/lpcusb/target/usbhw_lpc.c ****     
 682:../common/lpcusb/target/usbhw_lpc.c **** #else
 683:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL1 = (PINSEL1 & ~((3 << 26) | (3 << 28))) | (1 << 26) | (1 << 28);
 684:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL3 = (PINSEL3 & ~((3 << 4) | (3 << 28))) | (1 << 4) | (2 << 28);
 685:../common/lpcusb/target/usbhw_lpc.c ****     /* Due to a bug in the LPC23xx chips, the connection functionality must be
 686:../common/lpcusb/target/usbhw_lpc.c ****     * simulated using GPIO. Hopefully for production this will be fixed and the
 687:../common/lpcusb/target/usbhw_lpc.c ****     * commented out code will work */
 688:../common/lpcusb/target/usbhw_lpc.c ****     //PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18); /* Doesn't work due to bug in chip */
 689:../common/lpcusb/target/usbhw_lpc.c ****     PINSEL4 = (PINSEL4 & ~(3 << 18)); /* Use pin as GPIO */
 690:../common/lpcusb/target/usbhw_lpc.c ****     FIO2DIR |= (1<<9); /* Set pin to output */
 691:../common/lpcusb/target/usbhw_lpc.c ****     FIO2SET = (1<<9); /* Set output high to disconnect */
 692:../common/lpcusb/target/usbhw_lpc.c **** #endif
 693:../common/lpcusb/target/usbhw_lpc.c **** 
 694:../common/lpcusb/target/usbhw_lpc.c ****     // enable PUSB
 695:../common/lpcusb/target/usbhw_lpc.c ****     PCONP |= (1 << 31);     
 696:../common/lpcusb/target/usbhw_lpc.c **** 
 697:../common/lpcusb/target/usbhw_lpc.c ****   /* The LPC23xx uses a single PLL, and has multiple clock dividers for each
 698:../common/lpcusb/target/usbhw_lpc.c ****    * peripheral. These settings assume a PLL frequency of 288 MHz */
 699:../common/lpcusb/target/usbhw_lpc.c **** 
 700:../common/lpcusb/target/usbhw_lpc.c ****     USBCLKCFG = 5; /* 288 MHz / 48 MHz = 6 */
 701:../common/lpcusb/target/usbhw_lpc.c **** 
 702:../common/lpcusb/target/usbhw_lpc.c **** #ifdef LPC2378_PORTB
 703:../common/lpcusb/target/usbhw_lpc.c ****     USBClkCtrl = (1 << 1) | (1 << 3) | (1 << 4); /* Enable the clocks */
 704:../common/lpcusb/target/usbhw_lpc.c ****     while (!(USBClkSt & ((1 << 1) | (1 << 3) | (1 << 4))));
 705:../common/lpcusb/target/usbhw_lpc.c ****     USBPortSel = 0x3; /* Set LPC to use USB Port B pins */
 706:../common/lpcusb/target/usbhw_lpc.c **** #else
 707:../common/lpcusb/target/usbhw_lpc.c ****     USBClkCtrl = (1 << 1) | (1 << 4); /* Enable the clocks */
 708:../common/lpcusb/target/usbhw_lpc.c ****     while (!(USBClkSt & ((1 << 1) | (1 << 4))));
 709:../common/lpcusb/target/usbhw_lpc.c **** #endif
ARM GAS  /tmp/cc3mLhQ4.s 			page 32


 710:../common/lpcusb/target/usbhw_lpc.c **** 
 711:../common/lpcusb/target/usbhw_lpc.c **** #endif
 712:../common/lpcusb/target/usbhw_lpc.c ****     
 713:../common/lpcusb/target/usbhw_lpc.c ****     // disable/clear all interrupts for now
 714:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntEn = 0;
 1055              		.loc 1 714 0
 1056 0072 0C4B     		ldr	r3, .L106+16
 1057 0074 0020     		movs	r0, #0
 715:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntClr = 0xFFFFFFFF;
 1058              		.loc 1 715 0
 1059 0076 0C4A     		ldr	r2, .L106+20
 714:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntClr = 0xFFFFFFFF;
 1060              		.loc 1 714 0
 1061 0078 1860     		str	r0, [r3]
 1062              		.loc 1 715 0
 1063 007a 4FF0FF33 		mov	r3, #-1
 1064 007e 1360     		str	r3, [r2]
 716:../common/lpcusb/target/usbhw_lpc.c ****     USBDevIntPri = 0;
 1065              		.loc 1 716 0
 1066 0080 5062     		str	r0, [r2, #36]
 717:../common/lpcusb/target/usbhw_lpc.c **** 
 718:../common/lpcusb/target/usbhw_lpc.c ****     USBEpIntEn = 0;
 1067              		.loc 1 718 0
 1068 0082 D062     		str	r0, [r2, #44]
 719:../common/lpcusb/target/usbhw_lpc.c ****     USBEpIntClr = 0xFFFFFFFF;
 1069              		.loc 1 719 0
 1070 0084 1363     		str	r3, [r2, #48]
 720:../common/lpcusb/target/usbhw_lpc.c ****     USBEpIntPri = 0;
 1071              		.loc 1 720 0
 1072 0086 094B     		ldr	r3, .L106+24
 1073 0088 1860     		str	r0, [r3]
 721:../common/lpcusb/target/usbhw_lpc.c **** 
 722:../common/lpcusb/target/usbhw_lpc.c ****     // by default, only ACKs generate interrupts
 723:../common/lpcusb/target/usbhw_lpc.c ****     USBHwNakIntEnable(0);
 1074              		.loc 1 723 0
 1075 008a FFF7FEFF 		bl	USBHwNakIntEnable
 1076              	.LVL109:
 724:../common/lpcusb/target/usbhw_lpc.c ****     
 725:../common/lpcusb/target/usbhw_lpc.c ****     // init debug leds
 726:../common/lpcusb/target/usbhw_lpc.c ****     DEBUG_LED_INIT(8);
 727:../common/lpcusb/target/usbhw_lpc.c ****     DEBUG_LED_INIT(9);
 728:../common/lpcusb/target/usbhw_lpc.c ****     DEBUG_LED_INIT(10);
 729:../common/lpcusb/target/usbhw_lpc.c **** 
 730:../common/lpcusb/target/usbhw_lpc.c ****     return TRUE;
 731:../common/lpcusb/target/usbhw_lpc.c **** }
 1077              		.loc 1 731 0
 1078 008e 0120     		movs	r0, #1
 1079 0090 08BD     		pop	{r3, pc}
 1080              	.L107:
 1081 0092 00BF     		.align	2
 1082              	.L106:
 1083 0094 10C00240 		.word	1073922064
 1084 0098 C4C00F40 		.word	1074774212
 1085 009c F4CF0050 		.word	1342230516
 1086 00a0 F8CF0050 		.word	1342230520
 1087 00a4 04C20050 		.word	1342226948
 1088 00a8 08C20050 		.word	1342226952
ARM GAS  /tmp/cc3mLhQ4.s 			page 33


 1089 00ac 40C20050 		.word	1342227008
 1090              		.cfi_endproc
 1091              	.LFE21:
 1093              		.section	.text.USBSetupDMADescriptor,"ax",%progbits
 1094              		.align	1
 1095              		.global	USBSetupDMADescriptor
 1096              		.thumb
 1097              		.thumb_func
 1099              	USBSetupDMADescriptor:
 1100              	.LFB22:
 732:../common/lpcusb/target/usbhw_lpc.c **** 
 733:../common/lpcusb/target/usbhw_lpc.c **** 
 734:../common/lpcusb/target/usbhw_lpc.c **** 
 735:../common/lpcusb/target/usbhw_lpc.c **** 
 736:../common/lpcusb/target/usbhw_lpc.c **** 
 737:../common/lpcusb/target/usbhw_lpc.c **** 
 738:../common/lpcusb/target/usbhw_lpc.c **** //FIXME check all the DMA stuff
 739:../common/lpcusb/target/usbhw_lpc.c **** 
 740:../common/lpcusb/target/usbhw_lpc.c **** /**
 741:../common/lpcusb/target/usbhw_lpc.c ****     This function is used to setup and populated the various elements of a LPC2148 DMA desccriptor 
 742:../common/lpcusb/target/usbhw_lpc.c ****     after calling this function, the DMA descriptor could be used as part of a DMA tranfer.
 743:../common/lpcusb/target/usbhw_lpc.c ****     
 744:../common/lpcusb/target/usbhw_lpc.c ****         
 745:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] dmaDescriptor    A pointer to a 4 or 5 element long array of U32's that the DMA des
 746:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] nextDdPtr        The value to be placed in the "Next_DD_Pointer" value of the DMA d
 747:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] isIsocFlag       Flag to indicate if this DMA descriptor is for an ISOC endpoint (w
 748:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] maxPacketSize    The maximum packet size that can be sent/received for the endpoint
 749:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] dmaLengthIsocNumFrames    For non-ISOC endpoints, the number of bytes in the buffer
 750:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] dmaBufferStartAddress    Start address for the dma transfer (location to store data
 751:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] isocPacketSizeMemoryAddress   If a non-ISOC endpoint, set this to NULL, if an ISOC 
 752:../common/lpcusb/target/usbhw_lpc.c **** 
 753:../common/lpcusb/target/usbhw_lpc.c ****     @return  void
 754:../common/lpcusb/target/usbhw_lpc.c ****  */
 755:../common/lpcusb/target/usbhw_lpc.c **** void USBSetupDMADescriptor(
 756:../common/lpcusb/target/usbhw_lpc.c **** 		volatile U32 dmaDescriptor[], 
 757:../common/lpcusb/target/usbhw_lpc.c **** 		volatile U32 nextDdPtr[],
 758:../common/lpcusb/target/usbhw_lpc.c **** 		const U8 isIsocFlag, 
 759:../common/lpcusb/target/usbhw_lpc.c **** 		const U16 maxPacketSize, 
 760:../common/lpcusb/target/usbhw_lpc.c **** 		const U16 dmaLengthIsocNumFrames,
 761:../common/lpcusb/target/usbhw_lpc.c **** 		void *dmaBufferStartAddress,
 762:../common/lpcusb/target/usbhw_lpc.c **** 		U32 *isocPacketSizeMemoryAddress ) 
 763:../common/lpcusb/target/usbhw_lpc.c **** {
 1101              		.loc 1 763 0
 1102              		.cfi_startproc
 1103              		@ args = 12, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL110:
 1106 0000 30B5     		push	{r4, r5, lr}
 1107              		.cfi_def_cfa_offset 12
 1108              		.cfi_offset 4, -12
 1109              		.cfi_offset 5, -8
 1110              		.cfi_offset 14, -4
 764:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[1] = 0;
 1111              		.loc 1 764 0
 1112 0002 0025     		movs	r5, #0
 1113 0004 4560     		str	r5, [r0, #4]
 765:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[0] = (U32) nextDdPtr;
ARM GAS  /tmp/cc3mLhQ4.s 			page 34


 1114              		.loc 1 765 0
 1115 0006 0160     		str	r1, [r0]
 766:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[1] |= ((maxPacketSize & 0x3FF) << 5);//Set maxPacketSize
 1116              		.loc 1 766 0
 1117 0008 4568     		ldr	r5, [r0, #4]
 1118 000a C3F30903 		ubfx	r3, r3, #0, #10
 1119              	.LVL111:
 1120 000e 45EA4315 		orr	r5, r5, r3, lsl #5
 1121 0012 4560     		str	r5, [r0, #4]
 767:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[1] |= (dmaLengthIsocNumFrames << 16);//aka number of ISOC packets if in ISOC mode
 1122              		.loc 1 767 0
 1123 0014 4368     		ldr	r3, [r0, #4]
 1124 0016 BDF80C50 		ldrh	r5, [sp, #12]
 763:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[1] = 0;
 1125              		.loc 1 763 0
 1126 001a 059C     		ldr	r4, [sp, #20]
 1127              		.loc 1 767 0
 1128 001c 43EA0543 		orr	r3, r3, r5, lsl #16
 1129 0020 4360     		str	r3, [r0, #4]
 768:../common/lpcusb/target/usbhw_lpc.c **** 	if( isIsocFlag ) {
 1130              		.loc 1 768 0
 1131 0022 1AB1     		cbz	r2, .L109
 769:../common/lpcusb/target/usbhw_lpc.c **** 		dmaDescriptor[1] |= (1<<4);//enable isoc type
 1132              		.loc 1 769 0
 1133 0024 4368     		ldr	r3, [r0, #4]
 1134 0026 43F01003 		orr	r3, r3, #16
 1135 002a 4360     		str	r3, [r0, #4]
 1136              	.L109:
 770:../common/lpcusb/target/usbhw_lpc.c **** 	}
 771:../common/lpcusb/target/usbhw_lpc.c **** 	if( nextDdPtr != NULL ) {
 1137              		.loc 1 771 0
 1138 002c 19B1     		cbz	r1, .L110
 772:../common/lpcusb/target/usbhw_lpc.c **** 		dmaDescriptor[1] |= (1<<2); //mark next DD as valid
 1139              		.loc 1 772 0
 1140 002e 4368     		ldr	r3, [r0, #4]
 1141 0030 43F00403 		orr	r3, r3, #4
 1142 0034 4360     		str	r3, [r0, #4]
 1143              	.L110:
 773:../common/lpcusb/target/usbhw_lpc.c **** 	}
 774:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[2] = (U32) dmaBufferStartAddress;
 1144              		.loc 1 774 0
 1145 0036 049B     		ldr	r3, [sp, #16]
 1146 0038 8360     		str	r3, [r0, #8]
 775:../common/lpcusb/target/usbhw_lpc.c **** 	
 776:../common/lpcusb/target/usbhw_lpc.c **** 	if( isIsocFlag && isocPacketSizeMemoryAddress != NULL ) {
 1147              		.loc 1 776 0
 1148 003a 0AB1     		cbz	r2, .L111
 1149              		.loc 1 776 0 is_stmt 0 discriminator 1
 1150 003c 04B1     		cbz	r4, .L111
 777:../common/lpcusb/target/usbhw_lpc.c **** 		dmaDescriptor[4] = (U32) isocPacketSizeMemoryAddress;
 1151              		.loc 1 777 0 is_stmt 1
 1152 003e 0461     		str	r4, [r0, #16]
 1153              	.L111:
 778:../common/lpcusb/target/usbhw_lpc.c **** 	}
 779:../common/lpcusb/target/usbhw_lpc.c **** 	dmaDescriptor[3] = 0; //mark DD as valid and reset all status bits
 1154              		.loc 1 779 0
 1155 0040 0023     		movs	r3, #0
ARM GAS  /tmp/cc3mLhQ4.s 			page 35


 1156 0042 C360     		str	r3, [r0, #12]
 1157 0044 30BD     		pop	{r4, r5, pc}
 1158              		.cfi_endproc
 1159              	.LFE22:
 1161              		.section	.text.USBDisableDMAForEndpoint,"ax",%progbits
 1162              		.align	1
 1163              		.global	USBDisableDMAForEndpoint
 1164              		.thumb
 1165              		.thumb_func
 1167              	USBDisableDMAForEndpoint:
 1168              	.LFB23:
 780:../common/lpcusb/target/usbhw_lpc.c **** }
 781:../common/lpcusb/target/usbhw_lpc.c **** 
 782:../common/lpcusb/target/usbhw_lpc.c **** /**
 783:../common/lpcusb/target/usbhw_lpc.c ****     This function disables DMA for the endpoint indicated by the paramater.
 784:../common/lpcusb/target/usbhw_lpc.c ****         
 785:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEndpointNumber the endpoint number to be disabled.
 786:../common/lpcusb/target/usbhw_lpc.c **** 
 787:../common/lpcusb/target/usbhw_lpc.c ****     @return   void
 788:../common/lpcusb/target/usbhw_lpc.c ****  */
 789:../common/lpcusb/target/usbhw_lpc.c **** void USBDisableDMAForEndpoint(const U8 bEndpointNumber) {
 1169              		.loc 1 789 0
 1170              		.cfi_startproc
 1171              		@ args = 0, pretend = 0, frame = 0
 1172              		@ frame_needed = 0, uses_anonymous_args = 0
 1173              		@ link register save eliminated.
 1174              	.LVL112:
 1175              	.LVL113:
 790:../common/lpcusb/target/usbhw_lpc.c **** 	int idx = EP2IDX(bEndpointNumber);
 1176              		.loc 1 790 0
 1177 0000 00F00F03 		and	r3, r0, #15
 1178 0004 C009     		lsrs	r0, r0, #7
 1179              	.LVL114:
 1180 0006 40EA4300 		orr	r0, r0, r3, lsl #1
 791:../common/lpcusb/target/usbhw_lpc.c **** 	USBEpDMADis = (1<<idx);
 1181              		.loc 1 791 0
 1182 000a 0123     		movs	r3, #1
 1183 000c 03FA00F0 		lsl	r0, r3, r0
 1184 0010 014B     		ldr	r3, .L125
 1185 0012 1860     		str	r0, [r3]
 1186 0014 7047     		bx	lr
 1187              	.L126:
 1188 0016 00BF     		.align	2
 1189              	.L125:
 1190 0018 8CC20050 		.word	1342227084
 1191              		.cfi_endproc
 1192              	.LFE23:
 1194              		.section	.text.USBEnableDMAForEndpoint,"ax",%progbits
 1195              		.align	1
 1196              		.global	USBEnableDMAForEndpoint
 1197              		.thumb
 1198              		.thumb_func
 1200              	USBEnableDMAForEndpoint:
 1201              	.LFB24:
 792:../common/lpcusb/target/usbhw_lpc.c **** }
 793:../common/lpcusb/target/usbhw_lpc.c **** 
 794:../common/lpcusb/target/usbhw_lpc.c **** /**
ARM GAS  /tmp/cc3mLhQ4.s 			page 36


 795:../common/lpcusb/target/usbhw_lpc.c ****     Enables DMA for a particular endpoint.
 796:../common/lpcusb/target/usbhw_lpc.c ****         
 797:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEndpontNumber The endpoint to to enable DMA for.
 798:../common/lpcusb/target/usbhw_lpc.c **** 
 799:../common/lpcusb/target/usbhw_lpc.c ****     @return 
 800:../common/lpcusb/target/usbhw_lpc.c ****  */
 801:../common/lpcusb/target/usbhw_lpc.c **** void USBEnableDMAForEndpoint(const U8 bEndpointNumber) {
 1202              		.loc 1 801 0
 1203              		.cfi_startproc
 1204              		@ args = 0, pretend = 0, frame = 0
 1205              		@ frame_needed = 0, uses_anonymous_args = 0
 1206              		@ link register save eliminated.
 1207              	.LVL115:
 1208              	.LVL116:
 802:../common/lpcusb/target/usbhw_lpc.c **** 	int idx = EP2IDX(bEndpointNumber);
 1209              		.loc 1 802 0
 1210 0000 00F00F03 		and	r3, r0, #15
 1211 0004 C009     		lsrs	r0, r0, #7
 1212              	.LVL117:
 1213 0006 40EA4300 		orr	r0, r0, r3, lsl #1
 803:../common/lpcusb/target/usbhw_lpc.c **** 	USBEpDMAEn = (1<<idx);
 1214              		.loc 1 803 0
 1215 000a 0123     		movs	r3, #1
 1216 000c 03FA00F0 		lsl	r0, r3, r0
 1217 0010 014B     		ldr	r3, .L128
 1218 0012 1860     		str	r0, [r3]
 1219 0014 7047     		bx	lr
 1220              	.L129:
 1221 0016 00BF     		.align	2
 1222              	.L128:
 1223 0018 88C20050 		.word	1342227080
 1224              		.cfi_endproc
 1225              	.LFE24:
 1227              		.section	.text.USBInitializeISOCFrameArray,"ax",%progbits
 1228              		.align	1
 1229              		.global	USBInitializeISOCFrameArray
 1230              		.thumb
 1231              		.thumb_func
 1233              	USBInitializeISOCFrameArray:
 1234              	.LFB25:
 804:../common/lpcusb/target/usbhw_lpc.c **** }
 805:../common/lpcusb/target/usbhw_lpc.c **** 
 806:../common/lpcusb/target/usbhw_lpc.c **** /**
 807:../common/lpcusb/target/usbhw_lpc.c ****     This function is used to initialized an ISOC frame array
 808:../common/lpcusb/target/usbhw_lpc.c ****         
 809:../common/lpcusb/target/usbhw_lpc.c ****     @param [in|out] isocFrameArr        The array of ISOC frame descriptors to be set, it should po
 810:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] numElements             The number of elements in the isocFrameArr array.
 811:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] startFrameNumber        Number to start at for numbering each frame.
 812:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] defaultFrameLength      The frame length to set all the frame descriptors to.
 813:../common/lpcusb/target/usbhw_lpc.c **** 
 814:../common/lpcusb/target/usbhw_lpc.c ****     @return  void
 815:../common/lpcusb/target/usbhw_lpc.c ****  */
 816:../common/lpcusb/target/usbhw_lpc.c **** void USBInitializeISOCFrameArray(U32 isocFrameArr[], const U32 numElements, const U16 startFrameNum
 1235              		.loc 1 816 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 0
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc3mLhQ4.s 			page 37


 1239              	.LVL118:
 1240 0000 70B5     		push	{r4, r5, r6, lr}
 1241              		.cfi_def_cfa_offset 16
 1242              		.cfi_offset 4, -16
 1243              		.cfi_offset 5, -12
 1244              		.cfi_offset 6, -8
 1245              		.cfi_offset 14, -4
 1246              	.LVL119:
 817:../common/lpcusb/target/usbhw_lpc.c **** 	U16 i;
 818:../common/lpcusb/target/usbhw_lpc.c **** 	U16 frameNumber = startFrameNumber;
 819:../common/lpcusb/target/usbhw_lpc.c **** 	
 820:../common/lpcusb/target/usbhw_lpc.c **** 	for(i = 0; i < numElements; i++ ) {
 1247              		.loc 1 820 0
 1248 0002 0024     		movs	r4, #0
 1249              	.LVL120:
 1250              	.L131:
 1251 0004 A518     		adds	r5, r4, r2
 1252              		.loc 1 820 0 is_stmt 0 discriminator 1
 1253 0006 8C42     		cmp	r4, r1
 1254 0008 ADB2     		uxth	r5, r5
 1255              	.LVL121:
 1256 000a 0AD2     		bcs	.L133
 821:../common/lpcusb/target/usbhw_lpc.c **** 		isocFrameArr[i] = (frameNumber<<16) | (1<<15) | (defaultFrameLength & 0x3FF);
 1257              		.loc 1 821 0 is_stmt 1 discriminator 2
 1258 000c C3F30906 		ubfx	r6, r3, #0, #10
 1259 0010 46F40046 		orr	r6, r6, #32768
 1260 0014 46EA0545 		orr	r5, r6, r5, lsl #16
 1261              	.LVL122:
 1262 0018 40F82450 		str	r5, [r0, r4, lsl #2]
 1263              	.LVL123:
 820:../common/lpcusb/target/usbhw_lpc.c **** 		isocFrameArr[i] = (frameNumber<<16) | (1<<15) | (defaultFrameLength & 0x3FF);
 1264              		.loc 1 820 0 discriminator 2
 1265 001c 0134     		adds	r4, r4, #1
 1266              	.LVL124:
 1267 001e A4B2     		uxth	r4, r4
 1268              	.LVL125:
 1269 0020 F0E7     		b	.L131
 1270              	.LVL126:
 1271              	.L133:
 822:../common/lpcusb/target/usbhw_lpc.c **** 		frameNumber++;
 823:../common/lpcusb/target/usbhw_lpc.c **** 	}
 824:../common/lpcusb/target/usbhw_lpc.c **** }
 1272              		.loc 1 824 0
 1273 0022 70BD     		pop	{r4, r5, r6, pc}
 1274              		.cfi_endproc
 1275              	.LFE25:
 1277              		.section	.text.USBSetHeadDDForDMA,"ax",%progbits
 1278              		.align	1
 1279              		.global	USBSetHeadDDForDMA
 1280              		.thumb
 1281              		.thumb_func
 1283              	USBSetHeadDDForDMA:
 1284              	.LFB26:
 825:../common/lpcusb/target/usbhw_lpc.c **** 
 826:../common/lpcusb/target/usbhw_lpc.c **** /**
 827:../common/lpcusb/target/usbhw_lpc.c ****     This function is used to set the DMA descriptor head for the linked list of a particular endpoi
 828:../common/lpcusb/target/usbhw_lpc.c ****         
ARM GAS  /tmp/cc3mLhQ4.s 			page 38


 829:../common/lpcusb/target/usbhw_lpc.c ****     @param [in] bEp                    The endpoint number to set the DMA linked list head for.
 830:../common/lpcusb/target/usbhw_lpc.c ****     @param [in|out] udcaHeadArray      The array of pointers that point to the head DD elements for
 831:../common/lpcusb/target/usbhw_lpc.c ****     @param [in|out] dmaDescriptorPtr   The address of the DMA descriptor that is to be the new head
 832:../common/lpcusb/target/usbhw_lpc.c **** 
 833:../common/lpcusb/target/usbhw_lpc.c ****     @return 
 834:../common/lpcusb/target/usbhw_lpc.c ****  */
 835:../common/lpcusb/target/usbhw_lpc.c **** void USBSetHeadDDForDMA(const U8 bEp, volatile U32* udcaHeadArray[32], volatile U32 *dmaDescriptorP
 1285              		.loc 1 835 0
 1286              		.cfi_startproc
 1287              		@ args = 0, pretend = 0, frame = 0
 1288              		@ frame_needed = 0, uses_anonymous_args = 0
 1289              		@ link register save eliminated.
 1290              	.LVL127:
 836:../common/lpcusb/target/usbhw_lpc.c **** 	udcaHeadArray[EP2IDX(bEp)] = dmaDescriptorPtr;
 1291              		.loc 1 836 0
 1292 0000 00F00F03 		and	r3, r0, #15
 1293 0004 C009     		lsrs	r0, r0, #7
 1294              	.LVL128:
 1295 0006 40EA4300 		orr	r0, r0, r3, lsl #1
 1296 000a 41F82020 		str	r2, [r1, r0, lsl #2]
 1297 000e 7047     		bx	lr
 1298              		.cfi_endproc
 1299              	.LFE26:
 1301              		.section	.text.USBInitializeUSBDMA,"ax",%progbits
 1302              		.align	1
 1303              		.global	USBInitializeUSBDMA
 1304              		.thumb
 1305              		.thumb_func
 1307              	USBInitializeUSBDMA:
 1308              	.LFB27:
 837:../common/lpcusb/target/usbhw_lpc.c **** }
 838:../common/lpcusb/target/usbhw_lpc.c **** 
 839:../common/lpcusb/target/usbhw_lpc.c **** /**
 840:../common/lpcusb/target/usbhw_lpc.c ****     This function is used to initialize the USB DMA controller
 841:../common/lpcusb/target/usbhw_lpc.c ****         
 842:../common/lpcusb/target/usbhw_lpc.c ****     @param [in|out] udcaHeadArray   This is a pointer to the array of DMA descriptor linked-list he
 843:../common/lpcusb/target/usbhw_lpc.c **** 
 844:../common/lpcusb/target/usbhw_lpc.c ****     @return 
 845:../common/lpcusb/target/usbhw_lpc.c ****  */
 846:../common/lpcusb/target/usbhw_lpc.c **** void USBInitializeUSBDMA(volatile U32* udcaHeadArray[32]) {
 1309              		.loc 1 846 0
 1310              		.cfi_startproc
 1311              		@ args = 0, pretend = 0, frame = 0
 1312              		@ frame_needed = 0, uses_anonymous_args = 0
 1313              		@ link register save eliminated.
 1314              	.LVL129:
 1315              	.LVL130:
 1316              		.loc 1 846 0
 1317 0000 0023     		movs	r3, #0
 1318              	.LVL131:
 1319              	.L137:
 847:../common/lpcusb/target/usbhw_lpc.c **** 	//set following 32 pointers to be null
 848:../common/lpcusb/target/usbhw_lpc.c **** 	int i;
 849:../common/lpcusb/target/usbhw_lpc.c **** 	for(i = 0; i < 32; i++ ) {
 850:../common/lpcusb/target/usbhw_lpc.c **** 		udcaHeadArray[i] = NULL;
 1320              		.loc 1 850 0 discriminator 2
 1321 0002 0022     		movs	r2, #0
ARM GAS  /tmp/cc3mLhQ4.s 			page 39


 1322 0004 C250     		str	r2, [r0, r3]
 1323 0006 0433     		adds	r3, r3, #4
 849:../common/lpcusb/target/usbhw_lpc.c **** 		udcaHeadArray[i] = NULL;
 1324              		.loc 1 849 0 discriminator 2
 1325 0008 802B     		cmp	r3, #128
 1326 000a FAD1     		bne	.L137
 851:../common/lpcusb/target/usbhw_lpc.c **** 	}
 852:../common/lpcusb/target/usbhw_lpc.c **** 	USBUDCAH = (U32) udcaHeadArray;
 1327              		.loc 1 852 0
 1328 000c 014B     		ldr	r3, .L139
 1329 000e 1860     		str	r0, [r3]
 1330 0010 7047     		bx	lr
 1331              	.L140:
 1332 0012 00BF     		.align	2
 1333              	.L139:
 1334 0014 80C20050 		.word	1342227072
 1335              		.cfi_endproc
 1336              	.LFE27:
 1338              		.bss
 1339              		.align	2
 1340              		.set	.LANCHOR0,. + 0
 1343              	_apfnEPIntHandlers:
 1344 0000 00000000 		.space	64
 1344      00000000 
 1344      00000000 
 1344      00000000 
 1344      00000000 
 1347              	_pfnDevIntHandler:
 1348 0040 00000000 		.space	4
 1351              	_pfnFrameHandler:
 1352 0044 00000000 		.space	4
 1353              		.text
 1354              	.Letext0:
 1355              		.file 2 "../common/lpcusb/target/type.h"
 1356              		.file 3 "/usr/lib/gcc/arm-none-eabi/4.8.2/include/stdint-gcc.h"
 1357              		.file 4 "../common/lpcusb/target/usbapi.h"
ARM GAS  /tmp/cc3mLhQ4.s 			page 40


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbhw_lpc.c
     /tmp/cc3mLhQ4.s:19     .text.Wait4DevInt:0000000000000000 $t
     /tmp/cc3mLhQ4.s:23     .text.Wait4DevInt:0000000000000000 Wait4DevInt
     /tmp/cc3mLhQ4.s:46     .text.Wait4DevInt:0000000000000010 $d
     /tmp/cc3mLhQ4.s:52     .text.USBHwCmd:0000000000000000 $t
     /tmp/cc3mLhQ4.s:56     .text.USBHwCmd:0000000000000000 USBHwCmd
     /tmp/cc3mLhQ4.s:82     .text.USBHwCmd:0000000000000014 $d
     /tmp/cc3mLhQ4.s:87     .text.USBHwCmdWrite:0000000000000000 $t
     /tmp/cc3mLhQ4.s:91     .text.USBHwCmdWrite:0000000000000000 USBHwCmdWrite
     /tmp/cc3mLhQ4.s:123    .text.USBHwCmdWrite:000000000000001c $d
     /tmp/cc3mLhQ4.s:128    .text.USBHwEPConfig:0000000000000000 $t
     /tmp/cc3mLhQ4.s:133    .text.USBHwEPConfig:0000000000000000 USBHwEPConfig
     /tmp/cc3mLhQ4.s:188    .text.USBHwEPConfig:0000000000000034 $d
     /tmp/cc3mLhQ4.s:195    .text.USBHwRegisterEPIntHandler:0000000000000000 $t
     /tmp/cc3mLhQ4.s:200    .text.USBHwRegisterEPIntHandler:0000000000000000 USBHwRegisterEPIntHandler
     /tmp/cc3mLhQ4.s:236    .text.USBHwRegisterEPIntHandler:000000000000002c $d
     /tmp/cc3mLhQ4.s:242    .text.USBHwRegisterDevIntHandler:0000000000000000 $t
     /tmp/cc3mLhQ4.s:247    .text.USBHwRegisterDevIntHandler:0000000000000000 USBHwRegisterDevIntHandler
     /tmp/cc3mLhQ4.s:267    .text.USBHwRegisterDevIntHandler:0000000000000010 $d
     /tmp/cc3mLhQ4.s:273    .text.USBHwRegisterFrameHandler:0000000000000000 $t
     /tmp/cc3mLhQ4.s:278    .text.USBHwRegisterFrameHandler:0000000000000000 USBHwRegisterFrameHandler
     /tmp/cc3mLhQ4.s:298    .text.USBHwRegisterFrameHandler:0000000000000010 $d
     /tmp/cc3mLhQ4.s:304    .text.USBHwSetAddress:0000000000000000 $t
     /tmp/cc3mLhQ4.s:309    .text.USBHwSetAddress:0000000000000000 USBHwSetAddress
     /tmp/cc3mLhQ4.s:327    .text.USBHwConnect:0000000000000000 $t
     /tmp/cc3mLhQ4.s:332    .text.USBHwConnect:0000000000000000 USBHwConnect
     /tmp/cc3mLhQ4.s:352    .text.USBHwNakIntEnable:0000000000000000 $t
     /tmp/cc3mLhQ4.s:357    .text.USBHwNakIntEnable:0000000000000000 USBHwNakIntEnable
     /tmp/cc3mLhQ4.s:376    .text.USBHwEPGetStatus:0000000000000000 $t
     /tmp/cc3mLhQ4.s:381    .text.USBHwEPGetStatus:0000000000000000 USBHwEPGetStatus
     /tmp/cc3mLhQ4.s:425    .text.USBHwEPGetStatus:000000000000002c $d
     /tmp/cc3mLhQ4.s:431    .text.USBHwEPStall:0000000000000000 $t
     /tmp/cc3mLhQ4.s:436    .text.USBHwEPStall:0000000000000000 USBHwEPStall
     /tmp/cc3mLhQ4.s:462    .text.USBHwEPWrite:0000000000000000 $t
     /tmp/cc3mLhQ4.s:467    .text.USBHwEPWrite:0000000000000000 USBHwEPWrite
     /tmp/cc3mLhQ4.s:536    .text.USBHwEPWrite:0000000000000054 $d
     /tmp/cc3mLhQ4.s:543    .text.USBHwEPRead:0000000000000000 $t
     /tmp/cc3mLhQ4.s:548    .text.USBHwEPRead:0000000000000000 USBHwEPRead
     /tmp/cc3mLhQ4.s:646    .text.USBHwEPRead:0000000000000060 $d
     /tmp/cc3mLhQ4.s:653    .text.USBHwISOCEPRead:0000000000000000 $t
     /tmp/cc3mLhQ4.s:658    .text.USBHwISOCEPRead:0000000000000000 USBHwISOCEPRead
     /tmp/cc3mLhQ4.s:785    .text.USBHwISOCEPRead:0000000000000078 $d
     /tmp/cc3mLhQ4.s:792    .text.USBHwConfigDevice:0000000000000000 $t
     /tmp/cc3mLhQ4.s:797    .text.USBHwConfigDevice:0000000000000000 USBHwConfigDevice
     /tmp/cc3mLhQ4.s:817    .text.USBHwISR:0000000000000000 $t
     /tmp/cc3mLhQ4.s:822    .text.USBHwISR:0000000000000000 USBHwISR
     /tmp/cc3mLhQ4.s:980    .text.USBHwISR:00000000000000a8 $d
     /tmp/cc3mLhQ4.s:993    .text.USBHwInit:0000000000000000 $t
     /tmp/cc3mLhQ4.s:998    .text.USBHwInit:0000000000000000 USBHwInit
     /tmp/cc3mLhQ4.s:1083   .text.USBHwInit:0000000000000094 $d
     /tmp/cc3mLhQ4.s:1094   .text.USBSetupDMADescriptor:0000000000000000 $t
     /tmp/cc3mLhQ4.s:1099   .text.USBSetupDMADescriptor:0000000000000000 USBSetupDMADescriptor
     /tmp/cc3mLhQ4.s:1162   .text.USBDisableDMAForEndpoint:0000000000000000 $t
     /tmp/cc3mLhQ4.s:1167   .text.USBDisableDMAForEndpoint:0000000000000000 USBDisableDMAForEndpoint
     /tmp/cc3mLhQ4.s:1190   .text.USBDisableDMAForEndpoint:0000000000000018 $d
     /tmp/cc3mLhQ4.s:1195   .text.USBEnableDMAForEndpoint:0000000000000000 $t
ARM GAS  /tmp/cc3mLhQ4.s 			page 41


     /tmp/cc3mLhQ4.s:1200   .text.USBEnableDMAForEndpoint:0000000000000000 USBEnableDMAForEndpoint
     /tmp/cc3mLhQ4.s:1223   .text.USBEnableDMAForEndpoint:0000000000000018 $d
     /tmp/cc3mLhQ4.s:1228   .text.USBInitializeISOCFrameArray:0000000000000000 $t
     /tmp/cc3mLhQ4.s:1233   .text.USBInitializeISOCFrameArray:0000000000000000 USBInitializeISOCFrameArray
     /tmp/cc3mLhQ4.s:1278   .text.USBSetHeadDDForDMA:0000000000000000 $t
     /tmp/cc3mLhQ4.s:1283   .text.USBSetHeadDDForDMA:0000000000000000 USBSetHeadDDForDMA
     /tmp/cc3mLhQ4.s:1302   .text.USBInitializeUSBDMA:0000000000000000 $t
     /tmp/cc3mLhQ4.s:1307   .text.USBInitializeUSBDMA:0000000000000000 USBInitializeUSBDMA
     /tmp/cc3mLhQ4.s:1334   .text.USBInitializeUSBDMA:0000000000000014 $d
     /tmp/cc3mLhQ4.s:1339   .bss:0000000000000000 $d
     /tmp/cc3mLhQ4.s:1343   .bss:0000000000000000 _apfnEPIntHandlers
     /tmp/cc3mLhQ4.s:1347   .bss:0000000000000040 _pfnDevIntHandler
     /tmp/cc3mLhQ4.s:1351   .bss:0000000000000044 _pfnFrameHandler
                     .debug_frame:0000000000000010 $d

NO UNDEFINED SYMBOLS
